// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
"use strict";
/// <reference path="../typings/node.d.ts" />
/// <reference path="../typings/dictionary.d.ts" />
/// <reference path="../typings/tacoProjectInfo.d.ts" />
var domain = require("domain");
var os = require("os");
var path = require("path");
var Q = require("q");
var semver = require("semver");
var errorHelper = require("./tacoErrorHelper");
var installLogLevel = require("./installLogLevel");
var projectHelper = require("./projectHelper");
var tacoErrorCodes = require("./tacoErrorCodes");
var tacoPackageLoader = require("./tacoPackageLoader");
var ProjectHelper = projectHelper.ProjectHelper;
var TacoErrorCodes = tacoErrorCodes.TacoErrorCode;
var TacoPackageLoader = tacoPackageLoader.TacoPackageLoader;
var InstallLogLevel = installLogLevel.InstallLogLevel;
var TacoUtility;
(function (TacoUtility) {
    var CordovaHelper = (function () {
        function CordovaHelper() {
        }
        /**
         * Prepare the cordovaConfig parameter. This logic is taken directly from cordova and adapted to our CLI.
         */
        CordovaHelper.prepareCordovaConfig = function (parameters) {
            /*
            Re-implementation of Cordova's code:

            var cfg = {};
            // If we got a fourth parameter, consider it to be JSON to init the config.
            if (undashed[4]) {
                cfg = JSON.parse(undashed[4]);
            }
            var customWww = args['copy-from'] || args['link-to'];
            if (customWww) {
                if (customWww.indexOf('http') === 0) {
                    throw new CordovaError(
                        'Only local paths for custom www assets are supported.'
                        );
                }
                if (customWww.substr(0, 1) === '~') {  // resolve tilde in a naive way.
                    customWww = path.join(process.env.HOME, customWww.substr(1));
                }
                customWww = path.resolve(customWww);
                var wwwCfg = { url: customWww };
                if (args['link-to']) {
                    wwwCfg.link = true;
                }
                cfg.lib = cfg.lib || {};
                cfg.lib.www = wwwCfg;
            }
            */
            var config = {};
            // Verify if user specified a cordovaConfig parameter on the command line
            if (parameters.cordovaConfig) {
                config = JSON.parse(parameters.cordovaConfig);
            }
            // If the user specified custom www assets, adjust the cordovaConfig
            var customWww = parameters.copyFrom || parameters.linkTo;
            if (customWww) {
                if (customWww.indexOf("http") === 0) {
                    throw errorHelper.get(TacoErrorCodes.CommandCreateOnlyLocalCustomWww);
                }
                // Resolve HOME env path
                if (customWww.substr(0, 1) === "~") {
                    customWww = path.join(process.env.HOME, customWww.substr(1));
                }
                customWww = path.resolve(customWww);
                var wwwCfg = { url: customWww };
                if (parameters.linkTo) {
                    wwwCfg.link = true;
                }
                config.lib = config.lib || {};
                config.lib.www = wwwCfg;
            }
            parameters.cordovaConfig = config;
        };
        /**
         * Given a command line to Taco, construct a command line for Cordova with the same specified parameters
         * Note that this assumes that all arguments after a "--" are not for this command, but something else and so should be passed on.
         * With a command like "taco build --debug --remote -- ios android" this assumption isn't quite true
         */
        CordovaHelper.toCordovaCliArguments = function (commandData, platforms) {
            if (platforms === void 0) { platforms = null; }
            var cordovaArgs = platforms ? platforms : commandData.remain;
            Object.keys(CordovaHelper.CORDOVA_BOOLEAN_PARAMETERS).forEach(function (key) {
                if (commandData.options[key]) {
                    cordovaArgs.push("--" + key);
                }
            });
            Object.keys(CordovaHelper.CORDOVA_VALUE_PARAMETERS).forEach(function (key) {
                if (commandData.options[key]) {
                    cordovaArgs.push("--" + key);
                    cordovaArgs.push(commandData.options[key]);
                }
            });
            // Append all arguments after and including a lone "--"
            var additionalArguments = commandData.original.indexOf("--") >= 0 ? commandData.original.slice(commandData.original.indexOf("--")) : [];
            return cordovaArgs.concat(additionalArguments);
        };
        CordovaHelper.toCordovaRunArguments = function (cordovaVersion, commandData, platforms) {
            if (platforms === void 0) { platforms = null; }
            // Run, build, emulate, prepare and compile all use the same format at the moment
            return CordovaHelper.toCordovaArgumentsInternal(cordovaVersion, commandData, platforms);
        };
        CordovaHelper.toCordovaBuildArguments = function (cordovaVersion, commandData, platforms) {
            if (platforms === void 0) { platforms = null; }
            // Run, build, emulate, prepare and compile all use the same format at the moment
            return CordovaHelper.toCordovaArgumentsInternal(cordovaVersion, commandData, platforms);
        };
        CordovaHelper.toCordovaTargetsArguments = function (cordovaVersion, commandData, platforms) {
            if (platforms === void 0) { platforms = null; }
            // Run, build, emulate, prepare and compile all use the same format at the moment
            return CordovaHelper.toCordovaArgumentsInternal(cordovaVersion, commandData, platforms);
        };
        /**
         * Static method to get the plugin version specification from the config.xml file
         *
         * @param {string} The name(id) of the cordova plugin
         * @param {string} The path to config.xml of the project
         * @param {string} The cordova CLI version
         *
         * @return {Q.Promise<string>} A promise with the version specification as a string
         */
        CordovaHelper.getPluginVersionSpec = function (pluginId, projectInfo) {
            return CordovaHelper.getTargetVersionSpec(projectInfo, function (configParser) {
                var pluginEntry = configParser.getPlugin(pluginId);
                return pluginEntry ? pluginEntry.spec : "";
            });
        };
        /**
         * Static method to add the plugin specification to config.xml file
         *
         * @param {ICordovaPlatformPluginInfo } The plugin info
         * @param {string} The path to config.xml of the project
         * @param {string} The cordova CLI version
         *
         * @return {Q.Promise<string>} An empty promise
         */
        CordovaHelper.editPluginVersionSpecs = function (targetSpecs, projectInfo, addSpec) {
            return CordovaHelper.editConfigXml(projectInfo, function (configParser) {
                targetSpecs.forEach(function (targetSpec) {
                    configParser.removePlugin(targetSpec.name);
                    if (addSpec) {
                        configParser.addPlugin({ name: targetSpec.name, spec: targetSpec.spec }, targetSpec.pluginVariables);
                    }
                });
            });
        };
        /**
         * Static method to get the engine specification from the config.xml file
         *
         * @param {string} The platform name
         * @param {string} The path to config.xml of the project
         * @param {string} The cordova CLI version
         *
         * @return {Q.Promise<string>} A promise with the version specification as a string
         */
        CordovaHelper.getEngineVersionSpec = function (platformName, projectInfo) {
            return CordovaHelper.getTargetVersionSpec(projectInfo, function (configParser) {
                configParser.getEngines().forEach(function (engineInfo) {
                    if (engineInfo.name.toLowerCase() === platformName.toLowerCase()) {
                        return engineInfo.spec;
                    }
                });
                return "";
            });
        };
        /**
         * Static method to add the platform specification to config.xml file
         *
         * @param {string} The platform name
         * @param {string} The version specification for the platform
         * @param {string} The path to config.xml of the project
         * @param {string} The cordova CLI version
         *
         * @return {Q.Promise<string>} An empty promise
         */
        CordovaHelper.editEngineVersionSpecs = function (targetSpecs, projectInfo, addSpec) {
            return CordovaHelper.editConfigXml(projectInfo, function (configParser) {
                targetSpecs.forEach(function (targetSpec) {
                    configParser.removeEngine(targetSpec.name);
                    if (addSpec) {
                        configParser.addEngine(targetSpec.name, targetSpec.spec);
                    }
                });
            });
        };
        /**
         * Return a dictionary where the keys are supported platforms, or "null" if the answer is unknown.
         * For sufficiently recent kit projects, we can get an accurate answer via cordova.cordova_lib.cordova_platforms, while
         * for older versions of cordova or for non-kit projects, we default back to being permissive
         */
        CordovaHelper.getSupportedPlatforms = function () {
            return CordovaHelper.tryInvokeCordova(function (cordova) {
                if (!cordova.cordova_lib) {
                    // Older versions of cordova do not have a cordova_lib, so fall back to being permissive
                    return null;
                }
                else {
                    return cordova.cordova_lib.cordova_platforms;
                }
            }, function () { return null; });
        };
        /**
         * Given two functions, one which operates on a Cordova object and one which does not, this function will attempt to
         * get access to an appropriate Cordova object and invoke the first function. If we do not know which Cordova to use, then it
         * calls the second function instead.
         */
        CordovaHelper.tryInvokeCordova = function (cordovaFunction, otherFunction, options) {
            if (options === void 0) { options = {}; }
            return ProjectHelper.getProjectInfo().then(function (projectInfo) {
                if (projectInfo.cordovaCliVersion) {
                    return CordovaHelper.wrapCordovaInvocation(projectInfo.cordovaCliVersion, cordovaFunction, options.logLevel || InstallLogLevel.taco, options.isSilent);
                }
                else {
                    return otherFunction();
                }
            });
        };
        CordovaHelper.ensureCordovaVersionAcceptable = function (cliVersion) {
            if (semver.valid(cliVersion) && semver.lt(cliVersion, "5.4.0") && semver.gte(process.versions.node, "5.0.0")) {
                throw errorHelper.get(TacoErrorCodes.InvalidCordovaWithNode5);
            }
        };
        /**
         * Acquire the specified version of Cordova, and then invoke the given function with that Cordova as an argument.
         * The function invocation is wrapped in a domain, so any uncaught errors can be encapsulated, and the Cordova object
         * has listeners added to print any messages to the output.
         */
        CordovaHelper.wrapCordovaInvocation = function (cliVersion, func, logVerbosity, silent) {
            if (logVerbosity === void 0) { logVerbosity = InstallLogLevel.warn; }
            if (silent === void 0) { silent = false; }
            CordovaHelper.ensureCordovaVersionAcceptable(cliVersion);
            return TacoPackageLoader.lazyCordovaRequire(cliVersion, logVerbosity)
                .then(function (cordova) {
                if (!silent) {
                    cordova.on("results", console.info);
                    cordova.on("warn", console.warn);
                    cordova.on("error", console.error);
                    cordova.on("log", console.log);
                }
                var dom = domain.create();
                var deferred = Q.defer();
                dom.on("error", function (err) {
                    deferred.reject(errorHelper.wrap(TacoErrorCodes.CordovaCommandUnhandledException, err));
                    // Note: At this point the state can be arbitrarily bad, so we really shouldn't try to recover much from here
                });
                dom.run(function () {
                    Q(func(cordova)).done(function (result) { return deferred.resolve(result); }, function (err) { return deferred.reject(err); });
                });
                return deferred.promise.finally(function () {
                    if (!silent) {
                        cordova.off("results", console.info);
                        cordova.off("warn", console.warn);
                        cordova.off("error", console.error);
                        cordova.off("log", console.log);
                    }
                });
            });
        };
        CordovaHelper.getCordovaExecutable = function () {
            return ProjectHelper.getProjectInfo()
                .then(function (projectInfo) {
                if (projectInfo.cordovaCliVersion) {
                    return TacoPackageLoader.lazyCordovaRun(projectInfo.cordovaCliVersion);
                }
                else {
                    return CordovaHelper.globalCordovaCommandName;
                }
            })
                .catch(function (err) {
                return CordovaHelper.globalCordovaCommandName;
            });
        };
        /**
         * Construct the options for programatically calling emulate, build, prepare, compile, or run via cordova.raw.X
         */
        CordovaHelper.toCordovaArgumentsInternal = function (cordovaVersion, commandData, platforms) {
            if (platforms === void 0) { platforms = null; }
            if (semver.gte(cordovaVersion, CordovaHelper.RAW_API_540_VERSION)) {
                return CordovaHelper.toCordovaRaw540Arguments(commandData, platforms);
            }
            return CordovaHelper.toCordovaRawArguments(commandData, platforms);
        };
        /**
         * Construct the options for programatically calling emulate, build, prepare, compile, or run via cordova.raw.X, for the raw API of Cordova < 5.4.0
         */
        CordovaHelper.toCordovaRawArguments = function (commandData, platforms) {
            if (platforms === void 0) { platforms = null; }
            var opts = {
                platforms: platforms ? platforms : commandData.remain,
                options: [],
                verbose: commandData.options["verbose"] || false,
                silent: commandData.options["silent"] || false,
                browserify: commandData.options["browserify"] || false
            };
            // Reconstruct the args to be passed along to platform scripts.
            // This is an ugly temporary fix. The code spawning or otherwise
            // calling into platform code should be dealing with this based
            // on the parsed args object.
            var downstreamArgs = [];
            var argNames = ["debug", "release", "device", "emulator", "nobuild", "list"];
            argNames.forEach(function (flag) {
                if (commandData.options[flag]) {
                    downstreamArgs.push("--" + flag);
                }
            });
            if (commandData.options["target"]) {
                downstreamArgs.push("--target=" + commandData.options["target"]);
            }
            if (commandData.options["archs"]) {
                downstreamArgs.push("--archs=" + commandData.options["archs"]);
            }
            // Include all arguments after, but not including, a lone "--"
            var additionalArguments = commandData.original.indexOf("--") >= 0 ? commandData.original.slice(commandData.original.indexOf("--") + 1) : [];
            opts.options = downstreamArgs.concat(additionalArguments);
            return opts;
        };
        /**
         * Construct the options for programatically calling emulate, build, prepare, compile, or run via cordova.raw.X, for the raw API of Cordova >= 5.4.0
         */
        CordovaHelper.toCordovaRaw540Arguments = function (commandData, platforms) {
            if (platforms === void 0) { platforms = null; }
            var buildOpts = {
                archs: commandData.options["archs"] || null,
                argv: commandData.original.indexOf("--") >= 0 ? commandData.original.slice(commandData.original.indexOf("--") + 1) : [],
                buildconfig: commandData.options["buildconfig"] || null,
                debug: commandData.options["debug"] || false,
                device: commandData.options["device"] || false,
                emulator: commandData.options["emulator"] || false,
                nobuild: commandData.options["nobuild"] || false,
                release: commandData.options["release"] || false,
                target: commandData.options["target"] || null,
            };
            var cordovaArgs = {
                platforms: platforms ? platforms : commandData.remain,
                options: buildOpts,
                verbose: commandData.options["verbose"] || false,
                silent: commandData.options["silent"] || false,
                browserify: commandData.options["browserify"] || false
            };
            return cordovaArgs;
        };
        CordovaHelper.editConfigXml = function (projectInfo, editFunc) {
            return TacoPackageLoader.lazyCordovaRequire(projectInfo.cordovaCliVersion)
                .then(function (cordova) {
                var configParser = new cordova.cordova_lib.configparser(projectInfo.configXmlPath);
                editFunc(configParser);
                configParser.write();
            });
        };
        CordovaHelper.getTargetVersionSpec = function (projectInfo, readFunc) {
            return TacoPackageLoader.lazyCordovaRequire(projectInfo.cordovaCliVersion)
                .then(function (cordova) {
                var configParser = new cordova.cordova_lib.configparser(projectInfo.configXmlPath);
                return readFunc(configParser);
            });
        };
        // Cordova's known parameters
        CordovaHelper.CORDOVA_BOOLEAN_PARAMETERS = {
            verbose: Boolean,
            version: Boolean,
            help: Boolean,
            silent: Boolean,
            experimental: Boolean,
            noregistry: Boolean,
            shrinkwrap: Boolean,
            usegit: Boolean,
            link: Boolean,
            debug: Boolean,
            release: Boolean,
            device: Boolean,
            emulator: Boolean,
            browserify: Boolean,
            nobuild: Boolean,
            list: Boolean
        };
        CordovaHelper.CORDOVA_VALUE_PARAMETERS = {
            "copy-from": String,
            "link-to": path,
            searchpath: String,
            variable: Array,
            archs: String,
            target: String
        };
        CordovaHelper.RAW_API_540_VERSION = "5.4.0";
        CordovaHelper.globalCordovaCommandName = os.platform() === "win32" ? "cordova.cmd" : "cordova";
        return CordovaHelper;
    }());
    TacoUtility.CordovaHelper = CordovaHelper;
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=cordovaHelper.js.map
