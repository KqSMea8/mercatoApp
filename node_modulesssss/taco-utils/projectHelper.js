// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
"use strict";
/// <reference path="../typings/node.d.ts" />
/// <reference path="../typings/Q.d.ts" />
/// <reference path="../typings/tacoJsonMetadata.d.ts" />
/// <reference path="../typings/tacoJsonEditParams.d.ts" />
/// <reference path="../typings/tacoProjectInfo.d.ts" />
var child_process = require("child_process");
var fs = require("fs");
var Q = require("q");
var path = require("path");
var wrench = require("wrench");
var errorHelper = require("./tacoErrorHelper");
var jsonSerializer = require("./jsonSerializer");
var logger = require("./logger");
var tacoErrorCodes = require("./tacoErrorCodes");
var telemetryHelper = require("./telemetryHelper");
var utilHelper = require("./utilHelper");
var JsonSerializer = jsonSerializer.JsonSerializer;
var Logger = logger.Logger;
var TacoErrorCodes = tacoErrorCodes.TacoErrorCode;
var TelemetryHelper = telemetryHelper.TelemetryHelper;
var UtilHelper = utilHelper.UtilHelper;
var TacoUtility;
(function (TacoUtility) {
    /**
     *  A helper class with methods to query the project root, project info like CLI/kit version etc.
     */
    var ProjectHelper = (function () {
        function ProjectHelper() {
        }
        /**
         *  Helper to create the taco.json file in the project root {projectPath}. Invoked by
         *  the create command handler after the actual project creation
         */
        ProjectHelper.editTacoJsonFile = function (editParams, cordovaCliVersion) {
            ProjectHelper.cachedProjectInfo = null;
            ProjectHelper.cachedProjectFilePath = null;
            var deferred = Q.defer();
            var tacoJsonPath = path.resolve(editParams.projectPath, ProjectHelper.TACO_JSON_FILENAME);
            var tacoJson = fs.existsSync(tacoJsonPath) ? require(tacoJsonPath) : {};
            if (editParams.isKitProject) {
                tacoJson.kit = editParams.version;
                tacoJson["cordova-cli"] = cordovaCliVersion;
                return ProjectHelper.createJsonFileWithContents(tacoJsonPath, tacoJson);
            }
            else {
                if (tacoJson.kit) {
                    delete tacoJson.kit;
                }
                if (!editParams.version) {
                    deferred.reject(errorHelper.get(TacoErrorCodes.CommandCreateTacoJsonFileCreationError));
                    return deferred.promise;
                }
                tacoJson["cordova-cli"] = editParams.version;
                return ProjectHelper.createJsonFileWithContents(tacoJsonPath, tacoJson);
            }
        };
        /**
         *  Helper to find the root of the project. Invoked by taco command handlers to detect
         *  the project root directory. Returns null in the case of directories which are
         *  not cordova-based projects. Otherwise, the project root path as string.
         */
        ProjectHelper.getProjectRoot = function () {
            var projectPath = process.cwd();
            var parentPath;
            var atFsRoot = false;
            while (fs.existsSync(projectPath) && !fs.existsSync(path.join(projectPath, ProjectHelper.TACO_JSON_FILENAME)) && !fs.existsSync(path.join(projectPath, ProjectHelper.CONFIG_XML_FILENAME))) {
                // Navigate up one level until either taco.json is found or the parent path is invalid
                parentPath = path.resolve(projectPath, "..");
                if (parentPath !== projectPath) {
                    projectPath = parentPath;
                }
                else {
                    // we have reached the filesystem root
                    atFsRoot = true;
                    break;
                }
            }
            if (atFsRoot) {
                // We reached the fs root, so the project path passed was not a Cordova-based project directory
                return null;
            }
            return projectPath;
        };
        /**
         * Helper function to change the current directory to the project root, if possible.
         * If we can't find a taco.json then it will not change directory
         */
        ProjectHelper.cdToProjectRoot = function () {
            var tacoRoot = ProjectHelper.getProjectRoot();
            if (tacoRoot) {
                process.chdir(tacoRoot);
                // Cordova checks for process.env.PWD before checkign process.cwd, and process.env.PWD is not changed by process.chdir()
                // If we happened to be in a scenario where a taco project contained a separate cordova project, this way we ensure that
                // both taco and cordova will operate on the same project rather than our own taco stuff modifying things in tacoRoot and
                // cordova commands modifying things somewhere else.
                process.env.PWD = tacoRoot;
            }
        };
        /**
         *  Helper to get info regarding the current project.
         *  An object of type IProjectInfo is returned to the caller.
         */
        ProjectHelper.getProjectInfo = function () {
            return Q.fcall(ProjectHelper.getProjectRoot).then(function (projectPath) {
                var projectInfo = {
                    isTacoProject: false,
                    cordovaCliVersion: "",
                    configXmlPath: "",
                    tacoKitId: ""
                };
                if (!projectPath) {
                    return projectInfo;
                }
                var tacoJson;
                var tacoJsonFilePath = path.join(projectPath, ProjectHelper.TACO_JSON_FILENAME);
                var configFilePath = path.join(projectPath, ProjectHelper.CONFIG_XML_FILENAME);
                if (ProjectHelper.cachedProjectInfo) {
                    if (tacoJsonFilePath === ProjectHelper.cachedProjectFilePath) {
                        return ProjectHelper.cachedProjectInfo;
                    }
                    else {
                        ProjectHelper.cachedProjectInfo = null;
                    }
                }
                if (fs.existsSync(configFilePath)) {
                    projectInfo.configXmlPath = configFilePath;
                }
                if (fs.existsSync(tacoJsonFilePath)) {
                    tacoJson = UtilHelper.parseUserJSON(tacoJsonFilePath);
                    ProjectHelper.cachedProjectFilePath = tacoJsonFilePath;
                }
                else {
                    return projectInfo;
                }
                if (tacoJson.kit) {
                    projectInfo.isTacoProject = true;
                    projectInfo.tacoKitId = tacoJson.kit;
                    projectInfo.cordovaCliVersion = tacoJson["cordova-cli"];
                    return projectInfo;
                }
                else if (tacoJson["cordova-cli"]) {
                    projectInfo.isTacoProject = true;
                    projectInfo.cordovaCliVersion = tacoJson["cordova-cli"];
                    return projectInfo;
                }
                else {
                    return projectInfo;
                }
            }).then(function (projectInfo) {
                if (projectInfo.isTacoProject) {
                    ProjectHelper.cachedProjectInfo = Q(projectInfo);
                }
                return projectInfo;
            });
        };
        /**
         *  public helper that returns all the installed components - platforms/plugins
         */
        ProjectHelper.getInstalledComponents = function (projectDir, componentDirName) {
            var components = [];
            projectDir = projectDir || ProjectHelper.getProjectRoot();
            var componentDir = path.join(projectDir, componentDirName);
            if (!fs.existsSync(componentDir)) {
                return Q.resolve(components);
            }
            components = fs.readdirSync(componentDir).filter(function (component) {
                return fs.statSync(path.join(componentDir, component)).isDirectory();
            });
            return Q.resolve(components);
        };
        /**
         *  public helper that gets the version of the installed platforms
         */
        ProjectHelper.getInstalledPlatformVersions = function (projectDir) {
            projectDir = projectDir || ProjectHelper.getProjectRoot();
            var onWindows = process.platform === "win32";
            var deferred = Q.defer();
            var platformVersions = {};
            return ProjectHelper.getInstalledComponents(projectDir, "platforms")
                .then(function (platformsInstalled) {
                return Q.all(platformsInstalled.map(function (platform) {
                    var deferredProcPromise = Q.defer();
                    var cmdName = "version";
                    if (onWindows) {
                        cmdName = cmdName + ".bat";
                    }
                    var cmdPath = path.join(projectDir, "platforms", platform, "cordova", cmdName);
                    var versionProc = child_process.spawn(cmdPath);
                    versionProc.stdout.on("data", function (data) {
                        var version = data.toString();
                        platformVersions[platform] = version.trim();
                        deferredProcPromise.resolve(version);
                    });
                    return deferredProcPromise.promise;
                }));
            }).then(function () {
                deferred.resolve(platformVersions);
                return deferred.promise;
            });
        };
        /**
         *  public helper that gets the version of the installed plugins
         */
        ProjectHelper.getInstalledPluginVersions = function (projectDir) {
            projectDir = projectDir || ProjectHelper.getProjectRoot();
            var pluginVersions = {};
            return ProjectHelper.getInstalledComponents(projectDir, "plugins")
                .then(function (pluginsInstalled) {
                pluginsInstalled.forEach(function (plugin) {
                    // Ignore plugins without a package.json
                    var pluginPackgeJson = path.join(projectDir, "plugins", plugin, "package.json");
                    if (fs.existsSync(pluginPackgeJson)) {
                        var pluginInfo = require(pluginPackgeJson);
                        if (pluginInfo) {
                            pluginVersions[plugin] = pluginInfo["version"];
                        }
                    }
                });
                return Q.resolve(pluginVersions);
            });
        };
        /**
         *  public helper that gets the list of plugins that are 1. installed from the local file system or a GIT repository 2. that are not top-level plugins
         */
        ProjectHelper.getNonUpdatablePlugins = function (projectDir) {
            projectDir = projectDir || ProjectHelper.getProjectRoot();
            var nonUpdatablePlugins = [];
            var fetchJsonPath = path.resolve(projectDir, "plugins", "fetch.json");
            if (!fs.existsSync(path.resolve(projectDir, "plugins", "fetch.json"))) {
                return Q.resolve(nonUpdatablePlugins);
            }
            try {
                var fetchJson = require(fetchJsonPath);
                Object.keys(fetchJson).forEach(function (plugin) {
                    if ((fetchJson[plugin].source && fetchJson[plugin].source.type !== "registry") || !fetchJson[plugin]["is_top_level"]) {
                        nonUpdatablePlugins.push(plugin);
                    }
                });
            }
            catch (error) {
                Logger.log(error);
            }
            return Q.resolve(nonUpdatablePlugins);
        };
        /**
         *  public helper that serializes the JSON blob {jsonData} passed to a file @ {tacoJsonPath}
         */
        ProjectHelper.createJsonFileWithContents = function (tacoJsonPath, jsonData) {
            var deferred = Q.defer();
            // Write the JSON data to the file in the standard JSON format.
            // JsonSerializer class in the taco-utils does the necessary formatting
            // This is important as VS expects the JSON file to be in the standard JSON format
            var jsonSerializer = new JsonSerializer();
            var formattedTacoJson = jsonSerializer.serialize(jsonData);
            fs.writeFile(tacoJsonPath, formattedTacoJson, function (err) {
                if (err) {
                    deferred.reject(errorHelper.wrap(TacoErrorCodes.CommandCreateTacoJsonFileWriteError, err, tacoJsonPath));
                }
                deferred.resolve({});
            });
            return deferred.promise;
        };
        /**
         *  public helper that returns the common telemetry properties for the current project
         */
        ProjectHelper.getCurrentProjectTelemetryProperties = function (cliVersion) {
            var projectRoot = ProjectHelper.getProjectRoot();
            if (!projectRoot) {
                return Q.resolve({});
            }
            return ProjectHelper.getProjectInfo().then(function (projectInfo) {
                var isTsProject = ProjectHelper.isTypeScriptProject();
                var projectTelemetryProperties = {};
                if (projectInfo.isTacoProject) {
                    projectTelemetryProperties["isTacoProject"] = TelemetryHelper.telemetryProperty(true);
                    if (projectInfo.tacoKitId) {
                        projectTelemetryProperties["kit"] = TelemetryHelper.telemetryProperty(projectInfo.tacoKitId);
                    }
                    else {
                        projectTelemetryProperties["cli"] = TelemetryHelper.telemetryProperty(projectInfo.cordovaCliVersion);
                    }
                }
                else {
                    projectTelemetryProperties["isTacoProject"] = TelemetryHelper.telemetryProperty(false);
                }
                projectTelemetryProperties["projectType"] = TelemetryHelper.telemetryProperty(isTsProject ? "TypeScript" : "JavaScript");
                projectTelemetryProperties["cliVersion"] = TelemetryHelper.telemetryProperty(cliVersion);
                return Q.resolve(projectTelemetryProperties);
            });
        };
        /**
         *  public helper that resolves with a true value if the current project is a TACO TS project
         */
        ProjectHelper.isTypeScriptProject = function () {
            var projectRoot = ProjectHelper.getProjectRoot();
            if (!projectRoot) {
                return false;
            }
            var projectScriptsPath = path.resolve(projectRoot, ProjectHelper.PROJECTS_SCRIPTS_DIR);
            var tsFiles = [];
            if (fs.existsSync(projectScriptsPath)) {
                tsFiles = wrench.readdirSyncRecursive(projectScriptsPath).filter(function (file) {
                    return path.extname(file) === ".ts";
                });
            }
            return tsFiles.length > 0;
        };
        ProjectHelper.TACO_JSON_FILENAME = "taco.json";
        ProjectHelper.CONFIG_XML_FILENAME = "config.xml";
        ProjectHelper.PROJECTS_SCRIPTS_DIR = "scripts";
        ProjectHelper.cachedProjectInfo = null;
        ProjectHelper.cachedProjectFilePath = null;
        return ProjectHelper;
    }());
    TacoUtility.ProjectHelper = ProjectHelper;
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=projectHelper.js.map
