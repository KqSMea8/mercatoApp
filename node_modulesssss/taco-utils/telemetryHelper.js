// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../typings/commands.d.ts" />
/// <reference path="../typings/node.d.ts" />
/// <reference path="../typings/lodash.d.ts" />
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var _ = require("lodash");
var promisesUtils = require("./promisesUtils");
var telemetry = require("./telemetry");
var processUtils = require("./processUtils");
var Telemetry = telemetry.Telemetry;
var PromisesUtils = promisesUtils.PromisesUtils;
var TacoUtility;
(function (TacoUtility) {
    var TelemetryGeneratorBase = (function () {
        function TelemetryGeneratorBase(componentName) {
            this.telemetryProperties = {};
            this.currentStep = "initialStep";
            this.errorIndex = -1; // In case we have more than one error (We start at -1 because we increment it before using it)
            this.componentName = componentName;
            this.currentStepStartTime = processUtils.ProcessUtils.getProcess().hrtime();
        }
        TelemetryGeneratorBase.prototype.add = function (baseName, value, isPii) {
            return this.addWithPiiEvaluator(baseName, value, function () { return isPii; });
        };
        TelemetryGeneratorBase.prototype.addWithPiiEvaluator = function (baseName, value, piiEvaluator) {
            // We have 3 cases:
            //     * Object is an array, we add each element as baseNameNNN
            //     * Object is a hash, we add each element as baseName.KEY
            //     * Object is a value, we add the element as baseName
            try {
                if (Array.isArray(value)) {
                    this.addArray(baseName, value, piiEvaluator);
                }
                else if (_.isObject(value)) {
                    this.addHash(baseName, value, piiEvaluator);
                }
                else {
                    this.addString(baseName, String(value), piiEvaluator);
                }
            }
            catch (error) {
                // We don't want to crash the functionality if the telemetry fails.
                // This error message will be a javascript error message, so it's not pii
                this.addString("telemetryGenerationError." + baseName, String(error), function () { return false; });
            }
            return this;
        };
        TelemetryGeneratorBase.prototype.addError = function (error) {
            this.add("error.message" + ++this.errorIndex, error, /*isPii*/ true);
            var errorWithErrorCode = error;
            if (errorWithErrorCode.errorCode) {
                this.add("error.code" + this.errorIndex, errorWithErrorCode.errorCode, /*isPii*/ false);
            }
            return this;
        };
        TelemetryGeneratorBase.prototype.time = function (name, codeToMeasure) {
            var _this = this;
            var startTime;
            return PromisesUtils.wrapExecution(function () { return startTime = processUtils.ProcessUtils.getProcess().hrtime(); }, // Before
            codeToMeasure, function () { return _this.finishTime(name, startTime); }, // After
            function (reason) { return _this.addError(reason); }); // On failure
        };
        TelemetryGeneratorBase.prototype.step = function (name) {
            // First we finish measuring this step time, and we send a telemetry event for this step
            this.finishTime(this.currentStep, this.currentStepStartTime);
            this.sendCurrentStep();
            // Then we prepare to start gathering information about the next step
            this.currentStep = name;
            this.telemetryProperties = {};
            this.currentStepStartTime = processUtils.ProcessUtils.getProcess().hrtime();
            return this;
        };
        TelemetryGeneratorBase.prototype.send = function () {
            if (this.currentStep) {
                this.add("lastStepExecuted", this.currentStep, /*isPii*/ false);
            }
            this.step(null); // Send the last step
        };
        TelemetryGeneratorBase.prototype.sendCurrentStep = function () {
            this.add("step", this.currentStep, /*isPii*/ false);
            var telemetryEvent = new Telemetry.TelemetryEvent(Telemetry.appName + "/" + this.componentName);
            TelemetryHelper.addTelemetryEventProperties(telemetryEvent, this.telemetryProperties);
            this.sendTelemetryEvent(telemetryEvent);
        };
        TelemetryGeneratorBase.prototype.addArray = function (baseName, array, piiEvaluator) {
            var _this = this;
            // Object is an array, we add each element as baseNameNNN
            var elementIndex = 1; // We send telemetry properties in a one-based index
            array.forEach(function (element) { return _this.addWithPiiEvaluator(baseName + elementIndex++, element, piiEvaluator); });
        };
        TelemetryGeneratorBase.prototype.addHash = function (baseName, hash, piiEvaluator) {
            var _this = this;
            // Object is a hash, we add each element as baseName.KEY
            Object.keys(hash).forEach(function (key) { return _this.addWithPiiEvaluator(baseName + "." + key, hash[key], piiEvaluator); });
        };
        TelemetryGeneratorBase.prototype.addString = function (name, value, piiEvaluator) {
            this.telemetryProperties[name] = TelemetryHelper.telemetryProperty(value, piiEvaluator(value, name));
        };
        TelemetryGeneratorBase.prototype.combine = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i - 0] = arguments[_i];
            }
            var nonNullComponents = components.filter(function (component) { return !_.isNull(component); });
            return nonNullComponents.join(".");
        };
        TelemetryGeneratorBase.prototype.finishTime = function (name, startTime) {
            var endTime = processUtils.ProcessUtils.getProcess().hrtime(startTime);
            this.add(this.combine(name, "time"), String(endTime[0] * 1000 + endTime[1] / 1000000), /*isPii*/ false);
        };
        return TelemetryGeneratorBase;
    }());
    TacoUtility.TelemetryGeneratorBase = TelemetryGeneratorBase;
    var TelemetryGenerator = (function (_super) {
        __extends(TelemetryGenerator, _super);
        function TelemetryGenerator() {
            _super.apply(this, arguments);
        }
        TelemetryGenerator.prototype.sendTelemetryEvent = function (telemetryEvent) {
            Telemetry.send(telemetryEvent);
        };
        return TelemetryGenerator;
    }(TelemetryGeneratorBase));
    TacoUtility.TelemetryGenerator = TelemetryGenerator;
    var TelemetryHelper = (function () {
        function TelemetryHelper() {
        }
        TelemetryHelper.telemetryProperty = function (propertyValue, pii) {
            return { value: String(propertyValue), isPii: pii || false };
        };
        TelemetryHelper.addTelemetryEventProperties = function (event, properties) {
            if (!properties) {
                return;
            }
            Object.keys(properties).forEach(function (propertyName) {
                TelemetryHelper.addTelemetryEventProperty(event, propertyName, properties[propertyName].value, properties[propertyName].isPii);
            });
        };
        TelemetryHelper.sendCommandFailureTelemetry = function (commandName, error, projectProperties, args) {
            if (args === void 0) { args = null; }
            var errorEvent = TelemetryHelper.createBasicCommandTelemetry(commandName, args);
            if (error.isTacoError) {
                errorEvent.properties["tacoErrorCode"] = error.errorCode;
                errorEvent.properties["tacoErrorName"] = error.name;
            }
            else if (error.message) {
                errorEvent.setPiiProperty("errorMessage", error.message);
            }
            TelemetryHelper.addTelemetryEventProperties(errorEvent, projectProperties);
            Telemetry.send(errorEvent);
        };
        TelemetryHelper.sendCommandSuccessTelemetry = function (commandName, commandProperties, args) {
            if (args === void 0) { args = null; }
            var successEvent = TelemetryHelper.createBasicCommandTelemetry(commandName, args);
            TelemetryHelper.addTelemetryEventProperties(successEvent, commandProperties);
            Telemetry.send(successEvent);
        };
        TelemetryHelper.addTelemetryEventProperty = function (event, propertyName, propertyValue, isPii) {
            if (Array.isArray(propertyValue)) {
                TelemetryHelper.addMultiValuedTelemetryEventProperty(event, propertyName, propertyValue, isPii);
            }
            else {
                TelemetryHelper.setTelemetryEventProperty(event, propertyName, propertyValue, isPii);
            }
        };
        TelemetryHelper.addPropertiesFromOptions = function (telemetryProperties, knownOptions, commandOptions, nonPiiOptions) {
            var _this = this;
            if (nonPiiOptions === void 0) { nonPiiOptions = []; }
            // We parse only the known options, to avoid potential private information that may appear on the command line
            var unknownOptionIndex = 1;
            Object.keys(commandOptions).forEach(function (key) {
                var value = commandOptions[key];
                if (Object.keys(knownOptions).indexOf(key) >= 0) {
                    // This is a known option. We'll check the list to decide if it's pii or not
                    if (typeof (value) !== "undefined") {
                        // We encrypt all options values unless they are specifically marked as nonPii
                        telemetryProperties["options." + key] = _this.telemetryProperty(value, nonPiiOptions.indexOf(key) < 0);
                    }
                }
                else {
                    // This is a not known option. We'll assume that both the option and the value are pii
                    telemetryProperties["unknownOption" + unknownOptionIndex + ".name"] = _this.telemetryProperty(key, /*isPii*/ true);
                    telemetryProperties["unknownOption" + unknownOptionIndex++ + ".value"] = _this.telemetryProperty(value, /*isPii*/ true);
                }
            });
            return telemetryProperties;
        };
        TelemetryHelper.generate = function (name, codeGeneratingTelemetry) {
            var generator;
            return PromisesUtils.wrapExecution(function () { return generator = new TelemetryGenerator(name); }, // Before
            function () { return generator.time(null, function () { return codeGeneratingTelemetry(generator); }); }, function () { return generator.send(); }); // After
        };
        /**
         * Creates an object that can be passed to external modules to report telemetry events.
         * @param componentName - a name to prefix on the telemetry event names received from the external module.
         * @param baseProps - a collection of properties to include with all events.
         * @param errorHandler - an optional function to wrap or modify any errors (wrap in a TacoError, for example).
         * @returns {{sendTelemetry: (function(string, ITelemetryProperties, Error=): void)}}
         */
        TelemetryHelper.getExternalTelemetryObject = function (componentName, baseProps, errorHandler) {
            return {
                sendTelemetry: function (event, props, error) {
                    var telemetryProperties = {};
                    TelemetryHelper.addTelemetryProperties(telemetryProperties, baseProps);
                    TelemetryHelper.addTelemetryProperties(telemetryProperties, props);
                    var name = componentName + "/" + event;
                    if (error) {
                        if (errorHandler) {
                            error = errorHandler(error);
                        }
                        TelemetryHelper.sendCommandFailureTelemetry(name, error, telemetryProperties);
                    }
                    else {
                        TelemetryHelper.sendCommandSuccessTelemetry(name, telemetryProperties);
                    }
                }
            };
        };
        TelemetryHelper.addTelemetryProperties = function (telemetryProperties, newProps) {
            Object.keys(newProps).forEach(function (propName) {
                telemetryProperties[propName] = TelemetryHelper.telemetryProperty(newProps[propName]);
            });
        };
        TelemetryHelper.createBasicCommandTelemetry = function (commandName, args) {
            if (args === void 0) { args = null; }
            var commandEvent = new Telemetry.TelemetryEvent(Telemetry.appName + "/" + (commandName || "command"));
            if (!commandName && args && args.length > 0) {
                commandEvent.setPiiProperty("command", args[0]);
            }
            if (args) {
                TelemetryHelper.addTelemetryEventProperty(commandEvent, "argument", args, true);
            }
            return commandEvent;
        };
        TelemetryHelper.setTelemetryEventProperty = function (event, propertyName, propertyValue, isPii) {
            if (isPii) {
                event.setPiiProperty(propertyName, String(propertyValue));
            }
            else {
                event.properties[propertyName] = String(propertyValue);
            }
        };
        TelemetryHelper.addMultiValuedTelemetryEventProperty = function (event, propertyName, propertyValue, isPii) {
            for (var i = 0; i < propertyValue.length; i++) {
                TelemetryHelper.setTelemetryEventProperty(event, propertyName + i, propertyValue[i], isPii);
            }
        };
        return TelemetryHelper;
    }());
    TacoUtility.TelemetryHelper = TelemetryHelper;
    ;
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=telemetryHelper.js.map
