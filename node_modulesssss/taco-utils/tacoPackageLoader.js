// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../typings/rimraf.d.ts" />
/// <reference path="../typings/semver.d.ts" />
/// <reference path="../typings/dynamicDependencyEntry.d.ts" />
/// <reference path="../typings/tacoPackageLoader.d.ts" />
"use strict";
var assert = require("assert");
var fs = require("fs");
var mkdirp = require("mkdirp");
var os = require("os");
var path = require("path");
var rimraf = require("rimraf");
var semver = require("semver");
var Q = require("q");
var installLogLevel = require("./installLogLevel");
var loggerUtil = require("./logger");
var logLevel = require("./logLevel");
var resources = require("./resources/resourceManager");
var tacoErrorCodes = require("./tacoErrorCodes");
var errorHelper = require("./tacoErrorHelper");
var globalConfig = require("./tacoGlobalConfig");
var UtilHelper = require("./utilHelper");
var npmHelper = require("./npmHelper");
var InstallLogLevel = installLogLevel.InstallLogLevel;
var logger = loggerUtil.Logger;
var LogLevel = logLevel.LogLevel;
var TacoErrorCodes = tacoErrorCodes.TacoErrorCode;
var TacoGlobalConfig = globalConfig.TacoGlobalConfig;
var utils = UtilHelper.UtilHelper;
var NpmHelper = npmHelper.NpmHelper;
var TacoUtility;
(function (TacoUtility) {
    (function (PackageSpecType) {
        PackageSpecType[PackageSpecType["Error"] = -1] = "Error";
        PackageSpecType[PackageSpecType["Registry"] = 0] = "Registry";
        PackageSpecType[PackageSpecType["Uri"] = 1] = "Uri";
        PackageSpecType[PackageSpecType["FilePath"] = 2] = "FilePath";
    })(TacoUtility.PackageSpecType || (TacoUtility.PackageSpecType = {}));
    var PackageSpecType = TacoUtility.PackageSpecType;
    ;
    var TacoPackageLoader = (function () {
        function TacoPackageLoader() {
        }
        /* tslint:enable:member-ordering */
        /**
         * Returns a path to the specified command exported from the specified package. If the package is not already downloaded,
         * then first download and cache it locally.
         *
         * @param {string} packageName The name of the package to load
         * @param {string} packageId The version of the package to load. Either a version number such that "npm install package@version" works, or a git url to clone
         * @param {string} commandName The name of the binary to find
         * @param {LogLevel} logLevel Optional parameter which determines how much output from npm is filtered out.
         *                  Follows the npm syntax: silent, warn, info, verbose, silly
         *                  loglevel can also be used as "pretty" in which case, only formatted taco messages like Downloading cordova@5.0 are shown
         * @returns {Q.Promise<string>} A promise which is either rejected with a failure to find the local the binary or resolved with a path to the binary
         */
        TacoPackageLoader.lazyRun = function (packageName, packageId, commandName, logLevel) {
            if (logLevel === void 0) { logLevel = InstallLogLevel.warn; }
            var request = TacoPackageLoader.createPackageInstallRequest(packageName, packageId, logLevel);
            return TacoPackageLoader.installAndGetExecutable(packageName, commandName, request);
        };
        /**
         * Returns a path to the specified command exported from the specified Cordova package. If the package is not already downloaded,
         * then first download and cache it locally.
         *
         * @param {string} packageName The name of the package to load
         * @param {string} packageId The version of the package to load. Either a version number such that "npm install package@version" works, or a git url to clone
         * @param {string} commandName The name of the binary to find
         * @param {LogLevel} logLevel Optional parameter which determines how much output from npm is filtered out.
         *                  Follows the npm syntax: silent, warn, info, verbose, silly
         *                  loglevel can also be used as "pretty" in which case, only formatted taco messages like Downloading cordova@5.0 are shown
         * @returns {Q.Promise<string>} A promise which is either rejected with a failure to find the local the binary or resolved with a path to the binary
         */
        TacoPackageLoader.lazyCordovaRun = function (cordovaCliVersion, logLevel) {
            if (logLevel === void 0) { logLevel = InstallLogLevel.warn; }
            var request = TacoPackageLoader.createCordovaPackageInstallRequest(cordovaCliVersion, logLevel);
            return TacoPackageLoader.installAndGetExecutable(TacoPackageLoader.CORDOVA_NPM_PACKAGE_NAME, "cordova", request);
        };
        /**
         * Load a node package with specified version. If the package is not already downloaded,
         * then first download the package and cache it locally for future loads. The loaded package is cast to type T
         *
         * This method is resilient against interrupted downloads, but is not safe under concurrency.
         * Until that changes, we should not allow multiple builds at once.
         *
         * @param {string} packageName The name of the package to load
         * @param {string} packageVersion The version of the package to load. Either a version number such that "npm install package@version" works, or a git url to clone
         * @param {string} logLevel Optional parameter which determines how much output from npm is filtered out.
         *                  Follows the npm syntax: silent, warn, info, verbose, silly
         *                  loglevel can also be used as "taco" in which case, only formatted taco messages like Downloading cordova@5.0 are shown
         *
         *
         * @returns {Q.Promise<T>} A promise which is either rejected with a failure to install, or resolved with the require()'d package
         */
        TacoPackageLoader.lazyRequire = function (packageName, packageId, logLevel) {
            if (logLevel === void 0) { logLevel = InstallLogLevel.warn; }
            if (!this.mockForTests) {
                return TacoPackageLoader.lazyRequireInternal(TacoPackageLoader.createPackageInstallRequest(packageName, packageId, logLevel));
            }
            else {
                return this.mockForTests.lazyRequire(packageName, packageId, logLevel);
            }
        };
        /**
         * Load a Cordova package with specified version. If the package is not already downloaded,
         * then first download the package and cache it locally for future loads. The loaded package is cast to type T
         *
         * This method is resilient against interrupted downloads, but is not safe under concurrency.
         * Until that changes, we should not allow multiple builds at once.
         *
         * @param {string} packageVersion The version of the package to load. Either a version number such that "npm install package@version" works, or a git url to clone
         * @param {string} logLevel Optional parameter which determines how much output from npm is filtered out.
         *                  Follows the npm syntax: silent, warn, info, verbose, silly
         *                  loglevel can also be used as "taco" in which case, only formatted taco messages like Downloading cordova@5.0 are shown
         *
         *
         * @returns {Q.Promise<T>} A promise which is either rejected with a failure to install, or resolved with the require()'d package
         */
        TacoPackageLoader.lazyCordovaRequire = function (cordovaCliVersion, logLevel) {
            if (logLevel === void 0) { logLevel = InstallLogLevel.warn; }
            if (!this.mockForTests) {
                var request = TacoPackageLoader.createCordovaPackageInstallRequest(cordovaCliVersion, logLevel);
                return TacoPackageLoader.lazyRequireInternal(request);
            }
            else {
                return this.mockForTests.lazyRequire(TacoPackageLoader.CORDOVA_NPM_PACKAGE_NAME, TacoPackageLoader.CORDOVA_NPM_PACKAGE_NAME + "@" + cordovaCliVersion, logLevel);
            }
        };
        /**
         * Load a taco package with specified packageKey.
         * For development scenario, dependencyConfigPath maps a packageKey to a local folder on disk
         * For production scenario, dependencyConfigPath maps a packageKey to packageName@packageVersion or git url
         *
         * @param {string} packageKey a key to lookup in dependencyConfigPath, can be a packageName or any random string
         * @param {string} dependencyConfigPath Path to a json file which specifies key to packageId information along with other metadata like expirationIntervalInHours
         * @param {string} logLevel Optional parameter which determines how much output from npm and git is filtered out. Follows the npm syntax: silent, warn, info, verbose, silly
         *
         * @returns {Q.Promise<T>} A promise which is either rejected with a failure to install, or resolved with the require()'d package
         */
        TacoPackageLoader.lazyTacoRequire = function (packageKey, dependencyConfigPath, logLevel) {
            if (logLevel === void 0) { logLevel = InstallLogLevel.warn; }
            var request = TacoPackageLoader.createTacoPackageInstallRequest(packageKey, dependencyConfigPath, logLevel);
            assert.notEqual(request, null, "Invalid Package request");
            if (!request.expirationIntervalInHours || request.expirationIntervalInHours <= 0) {
                return TacoPackageLoader.lazyRequireInternal(request);
            }
            return TacoPackageLoader.lazyRequireExpirable(request);
        };
        TacoPackageLoader.lazyRequireExpirable = function (request) {
            var requireCachePaths = Object.keys(require.cache);
            return TacoPackageLoader.lazyRequireLatest(request)
                .finally(function () {
                // un-cache any files that were just required.
                Object.keys(require.cache).forEach(function (key) {
                    if (requireCachePaths.indexOf(key) === -1) {
                        delete require.cache[key];
                    }
                });
            });
        };
        TacoPackageLoader.lazyRequireLatest = function (request) {
            assert.notEqual(request.type, PackageSpecType.Uri, "update is not supported for git URIs");
            // Check if update is needed
            return TacoPackageLoader.getLastCheckTimestamp(request.targetPath)
                .then(function (lastCheckTimestamp) {
                if (lastCheckTimestamp < 0) {
                    // No previous version, we must download something
                    return TacoPackageLoader.lazyRequireInternal(request).then(function (obj) {
                        TacoPackageLoader.updateLastCheckTimestamp(request.targetPath);
                        return Q(obj);
                    });
                }
                else {
                    // A previous version exists. If we can't acquire a new one,
                    // we may continue using the previous version
                    var updateRequested = (Date.now() - lastCheckTimestamp) > request.expirationIntervalInHours * 60 * 60 * 1000;
                    if (updateRequested) {
                        var targetPath = request.targetPath;
                        var backupPath = request.targetPath + "_backup";
                        try {
                            if (fs.existsSync(backupPath)) {
                                rimraf.sync(backupPath);
                            }
                            fs.renameSync(targetPath, backupPath);
                        }
                        catch (e) {
                            if (TacoGlobalConfig.logLevel === LogLevel.Diagnostic) {
                                logger.logWarning(e.toString());
                            }
                        }
                        return TacoPackageLoader.lazyRequireInternal(request).then(function (obj) {
                            try {
                                rimraf.sync(backupPath);
                            }
                            catch (e) {
                                if (TacoGlobalConfig.logLevel === LogLevel.Diagnostic) {
                                    logger.logWarning(e.toString());
                                }
                            }
                            TacoPackageLoader.updateLastCheckTimestamp(request.targetPath);
                            return Q(obj);
                        }, function (error) {
                            try {
                                logger.logWarning(error.toString());
                                rimraf.sync(targetPath);
                                fs.renameSync(backupPath, targetPath);
                                return TacoPackageLoader.lazyRequireInternal(request);
                            }
                            catch (e) {
                                // An error happened, either when deleting the attempted new install, or when moving the backup in to place
                                throw errorHelper.wrap(TacoErrorCodes.PackageLoaderUpdateUnableToRecover, e, targetPath);
                            }
                        });
                    }
                    else {
                        // Just use the cached version, no need to download a new version and update timestamps
                        return TacoPackageLoader.lazyRequireInternal(request);
                    }
                }
            });
        };
        TacoPackageLoader.lazyRequireInternal = function (request) {
            assert.notEqual(request, null);
            return Q({})
                .then(function () {
                return TacoPackageLoader.installPackageIfNeeded(request);
            })
                .then(function () {
                return TacoPackageLoader.requirePackage(request.targetPath);
            });
        };
        TacoPackageLoader.createPackageInstallRequest = function (packageName, packageId, logLevel, expirationIntervalInHours) {
            var packageType = PackageSpecType.Error;
            // The packageId can either be a GIT url, a local file path or name@version (cordova@4.3)
            if ((TacoPackageLoader.GIT_URI_REGEX.test(packageId))) {
                packageType = PackageSpecType.Uri;
            }
            else if (TacoPackageLoader.FILE_URI_REGEX.test(packageId)) {
                packageId = packageId.substring(TacoPackageLoader.FILE_REGEX_PREFIX.length);
                packageType = PackageSpecType.FilePath;
            }
            else {
                // moving this down after Uri/FilePath because both can have '@'. Parse the packageId to retrieve packageVersion
                var packageVersion = packageId.split("@")[1];
                if (!packageVersion || semver.valid(packageVersion)) {
                    packageType = PackageSpecType.Registry;
                }
            }
            var homePackageModulesPath = path.join(utils.tacoHome, "node_modules", packageName);
            switch (packageType) {
                case PackageSpecType.Registry:
                    var versionSubFolder = packageId.split("@")[1] || "latest";
                    return {
                        packageName: packageName,
                        type: packageType,
                        packageId: packageId,
                        targetPath: path.join(homePackageModulesPath, versionSubFolder, "node_modules", packageName),
                        expirationIntervalInHours: expirationIntervalInHours,
                        logLevel: logLevel
                    };
                case PackageSpecType.Uri:
                case PackageSpecType.FilePath:
                    return {
                        packageName: packageName,
                        type: packageType,
                        packageId: packageId,
                        targetPath: path.join(homePackageModulesPath, encodeURIComponent(packageId), "node_modules", packageName),
                        commandFlags: ["--production"],
                        expirationIntervalInHours: expirationIntervalInHours,
                        logLevel: logLevel
                    };
                case PackageSpecType.Error:
                    throw errorHelper.get(TacoErrorCodes.PackageLoaderInvalidPackageVersionSpecifier, packageId.split("@")[1], packageName);
            }
        };
        TacoPackageLoader.createCordovaPackageInstallRequest = function (cordovaCliVersion, logLevel) {
            var request = TacoPackageLoader.createPackageInstallRequest(TacoPackageLoader.CORDOVA_NPM_PACKAGE_NAME, TacoPackageLoader.CORDOVA_NPM_PACKAGE_NAME + "@" + cordovaCliVersion, logLevel);
            if (process.env.testCordovaVersion) {
                request.packageId = "cordova@" + process.env.testCordovaVersion;
            }
            return request;
        };
        TacoPackageLoader.installAndGetExecutable = function (packageName, commandName, request) {
            return Q({})
                .then(function () {
                return TacoPackageLoader.installPackageIfNeeded(request);
            })
                .then(function () {
                var packageJsonFilePath = path.join(request.targetPath, "package.json");
                var packageJson = JSON.parse(fs.readFileSync(packageJsonFilePath, "utf8"));
                if (packageJson.bin && packageJson.bin[commandName]) {
                    var commandFilePath = path.join(request.targetPath, "..", ".bin", commandName);
                    if (os.platform() === "win32") {
                        commandFilePath += ".cmd";
                    }
                    if (fs.existsSync(commandFilePath)) {
                        return Q.resolve(commandFilePath);
                    }
                }
                return Q.reject(errorHelper.get(TacoErrorCodes.PackageLoaderRunPackageDoesntHaveRequestedBinary, packageName, commandName));
            });
        };
        TacoPackageLoader.createTacoPackageInstallRequest = function (packageKey, dependencyConfigPath, logLevel) {
            if (fs.existsSync(dependencyConfigPath)) {
                try {
                    var dependencyLookup = JSON.parse(fs.readFileSync(dependencyConfigPath, "utf8"));
                    var packageEntry = dependencyLookup[packageKey];
                    if (packageEntry) {
                        // if a local path is specified use that otherwise fallback to packageName@packageVersion
                        var packageId = packageEntry.localPath || packageEntry.packageId;
                        return TacoPackageLoader.createPackageInstallRequest(packageEntry.packageName, packageId, logLevel, packageEntry.expirationIntervalInHours);
                    }
                }
                catch (exception) {
                    assert.fail(exception, null, "dynamic dependencies file " + dependencyConfigPath + " is missing or corrupted");
                }
            }
            return null;
        };
        TacoPackageLoader.installPackageViaNPM = function (request) {
            if (request.logLevel >= InstallLogLevel.taco) {
                logger.logLine();
                logger.log(resources.getString("PackageLoaderDownloadingMessage", request.packageId));
            }
            return Q.denodeify(mkdirp)(request.targetPath).then(function () {
                var cwd = path.resolve(request.targetPath, "..", "..");
                return NpmHelper.install(request.packageId, cwd, request.commandFlags, request.logLevel).then(function () {
                    if (request.logLevel >= InstallLogLevel.taco) {
                        logger.logLine();
                        logger.log(resources.getString("PackageLoaderDownloadCompletedMessage", request.packageId));
                    }
                }).catch(function (err) {
                    var deferred = Q.defer();
                    rimraf(request.targetPath, function () {
                        if (request.logLevel >= InstallLogLevel.taco) {
                            logger.logLine();
                            logger.logError(resources.getString("PackageLoaderDownloadError", request.packageId));
                        }
                        if (isFinite(err)) {
                            if (request.logLevel > InstallLogLevel.silent) {
                                logger.logError(resources.getString("PackageLoaderNpmInstallFailedConsoleMessage"));
                            }
                            // 243 is the error code reported when npm fails due to EACCES
                            var errorCode = (err === 243) ? TacoErrorCodes.PackageLoaderNpmInstallFailedEaccess : TacoErrorCodes.PackageLoaderNpmInstallFailedWithCode;
                            deferred.reject(errorHelper.get(errorCode, request.packageName, err));
                        }
                        else {
                            deferred.reject(errorHelper.wrap(TacoErrorCodes.PackageLoaderNpmInstallErrorMessage, err, request.packageName));
                        }
                    });
                    return deferred.promise;
                });
            });
        };
        TacoPackageLoader.installPackageIfNeeded = function (request) {
            return Q({}).then(function () {
                if (!TacoPackageLoader.packageNeedsInstall(request.targetPath)) {
                    return Q.resolve(null);
                }
                // Delete the target path if it already exists and create an empty folder
                if (fs.existsSync(request.targetPath)) {
                    rimraf.sync(request.targetPath);
                }
                mkdirp.sync(request.targetPath);
                // Create a file 
                fs.closeSync(fs.openSync(TacoPackageLoader.getStatusFilePath(request.targetPath), "w"));
                return TacoPackageLoader.installPackageViaNPM(request).then(function () {
                    return TacoPackageLoader.removeStatusFile(request.targetPath);
                });
            });
        };
        TacoPackageLoader.requirePackage = function (packageTargetPath) {
            return require(packageTargetPath);
        };
        TacoPackageLoader.getStatusFilePath = function (targetPath) {
            return path.resolve(targetPath, "..", "Installing.tmp");
        };
        TacoPackageLoader.removeStatusFile = function (targetPath) {
            var statusFilePath = TacoPackageLoader.getStatusFilePath(targetPath);
            return Q.denodeify(fs.unlink)(statusFilePath);
        };
        TacoPackageLoader.packageNeedsInstall = function (targetPath) {
            var statusFilePath = TacoPackageLoader.getStatusFilePath(targetPath);
            // if package.json doesn't exist or status file is still lingering around
            // it is an invalid installation
            return !fs.existsSync(path.join(targetPath, "package.json")) || fs.existsSync(statusFilePath);
        };
        TacoPackageLoader.getTimestampFilePath = function (targetPath) {
            return path.resolve(targetPath, "..", "..", "timestamp.txt");
        };
        TacoPackageLoader.getLastCheckTimestamp = function (targetPath) {
            return Q.denodeify(fs.readFile)(TacoPackageLoader.getTimestampFilePath(targetPath))
                .then(function (data) {
                return parseInt(data.toString(), 10);
            })
                .catch(function (error) {
                return -1;
            });
        };
        TacoPackageLoader.updateLastCheckTimestamp = function (targetPath) {
            try {
                fs.writeFileSync(TacoPackageLoader.getTimestampFilePath(targetPath), Date.now().toString());
            }
            catch (e) {
                logger.logError(e);
            }
        };
        /* tslint:disable:member-ordering */
        // Need to declare FILE_REGEX_PREFIX before FILE_URI_REGEX, but don't want to expose it outside the class
        TacoPackageLoader.FILE_REGEX_PREFIX = "file://";
        TacoPackageLoader.CORDOVA_NPM_PACKAGE_NAME = "cordova";
        TacoPackageLoader.GIT_URI_REGEX = /(^http(s?):\/\/.*)|(.*\.git(#.*)?$)/;
        TacoPackageLoader.FILE_URI_REGEX = new RegExp("^" + TacoPackageLoader.FILE_REGEX_PREFIX + ".*");
        return TacoPackageLoader;
    }());
    TacoUtility.TacoPackageLoader = TacoPackageLoader;
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=tacoPackageLoader.js.map
