// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../typings/cordovaExtensions.d.ts" />
/// <reference path="../typings/node.d.ts" />
/// <reference path="../typings/Q.d.ts" />
/// <reference path="../typings/semver.d.ts" />
"use strict";
var assert = require("assert");
var child_process = require("child_process");
var Q = require("q");
var semver = require("semver");
var errorHelper = require("./tacoErrorHelper");
var cordovaHelper = require("./cordovaHelper");
var installLogLevel = require("./installLogLevel");
var projectHelper = require("./projectHelper");
var tacoErrorCodes = require("./tacoErrorCodes");
var CordovaHelper = cordovaHelper.CordovaHelper;
var ProjectHelper = projectHelper.ProjectHelper;
var TacoErrorCodes = tacoErrorCodes.TacoErrorCode;
var InstallLogLevel = installLogLevel.InstallLogLevel;
var TacoUtility;
(function (TacoUtility) {
    var CordovaWrapper = (function () {
        function CordovaWrapper() {
        }
        CordovaWrapper.cli = function (args, captureOutput) {
            captureOutput = captureOutput || false;
            return CordovaHelper.getCordovaExecutable().then(function (executablePath) {
                var deferred = Q.defer();
                var output = "";
                var errorOutput = "";
                var options = captureOutput ? { stdio: "pipe" } : { stdio: "inherit" };
                var proc = child_process.spawn(executablePath, args, options);
                proc.on("error", function (err) {
                    // ENOENT error thrown if no Cordova.cmd is found
                    var tacoError = (err.code === "ENOENT") ?
                        errorHelper.get(TacoErrorCodes.CordovaCmdNotFound) :
                        errorHelper.wrap(TacoErrorCodes.CordovaCommandFailedWithError, err, args.join(" "));
                    deferred.reject(tacoError);
                });
                if (captureOutput) {
                    proc.stdout.on("data", function (data) {
                        output += data.toString();
                    });
                    proc.stderr.on("data", function (data) {
                        errorOutput += data.toString();
                    });
                }
                proc.on("close", function (code) {
                    if (code) {
                        // Special handling for 'cordova requirements': this Cordova command returns an error when some requirements are not installed, when technically this is not really an error (the command executes
                        // correctly and reports that some requirements are missing). In that case, if the captureOutput flag is set, we don't want to report an error. To detect this case, we have to parse the returned
                        // error output because there is no specific error code for this case. For now, we just look for the "Some of requirements check failed" sentence.
                        if (captureOutput && output && args[0] === "requirements" && code === 1 && errorOutput && errorOutput.indexOf("Some of requirements check failed") !== -1) {
                            deferred.resolve(output);
                        }
                        else {
                            var tacoError = errorOutput ?
                                errorHelper.wrap(TacoErrorCodes.CordovaCommandFailedWithError, new Error(errorOutput), args.join(" ")) :
                                errorHelper.get(TacoErrorCodes.CordovaCommandFailed, code, args.join(" "));
                            deferred.reject(tacoError);
                        }
                    }
                    else {
                        if (captureOutput && output) {
                            deferred.resolve(output);
                        }
                        else {
                            deferred.resolve("");
                        }
                    }
                });
                return deferred.promise;
            });
        };
        CordovaWrapper.build = function (commandData, platforms) {
            platforms = platforms || null;
            return CordovaWrapper.getCordovaVersion().then(function (cordovaVersion) {
                return CordovaWrapper.cordovaApiOrProcess(function (cordova) {
                    return cordova.raw.build(CordovaHelper.toCordovaBuildArguments(cordovaVersion, commandData, platforms));
                }, function () { return ["build"].concat(CordovaHelper.toCordovaCliArguments(commandData, platforms)); });
            });
        };
        /**
         * Static method to invoke cordova platform command
         *
         * @param {string} The name of the platform sub-command to be invoked
         * @param {ICommandData} wrapping commandData object
         * @param {string} list of platforms to add/remove
         * @param {ICordovaPlatformOptions} platform options if any
         *
         * @return {Q.Promise<any>} An empty promise
         */
        CordovaWrapper.platform = function (subCommand, commandData, platforms, options, isSilent) {
            isSilent = isSilent || false;
            return CordovaWrapper.cordovaApiOrProcess(function (cordova) {
                return cordova.raw.platform(subCommand, platforms, options);
            }, function () {
                assert(commandData);
                return ["platform"].concat(CordovaHelper.toCordovaCliArguments(commandData));
            }, { logLevel: InstallLogLevel.warn, isSilent: isSilent }); // Subscribe to event listeners only if we are not in silent mode
        };
        /**
         * Static method to invoke cordova plugin command
         *
         * @param {string} The name of the plugin sub-command to be invoked
         * @param {string} list of plugins to add/remove
         * @param {ICordovaPluginOptions} plugin options if any
         * @param {ICommandData} wrapping commandData object
         *
         * @return {Q.Promise<any>} An empty promise
         */
        CordovaWrapper.plugin = function (subCommand, commandData, plugins, options, isSilent) {
            isSilent = isSilent || false;
            return CordovaWrapper.cordovaApiOrProcess(function (cordova) {
                return cordova.raw.plugin(subCommand, plugins, options);
            }, function () {
                assert(commandData);
                return ["plugin"].concat(CordovaHelper.toCordovaCliArguments(commandData));
            }, { logLevel: InstallLogLevel.warn, isSilent: isSilent }); // Subscribe to event listeners only if we are not in silent mode
        };
        CordovaWrapper.emulate = function (commandData, platforms) {
            platforms = platforms || null;
            return CordovaWrapper.getCordovaVersion().then(function (cordovaVersion) {
                return CordovaWrapper.cordovaApiOrProcess(function (cordova) {
                    return cordova.raw.emulate(CordovaHelper.toCordovaRunArguments(cordovaVersion, commandData, platforms));
                }, function () { return ["emulate"].concat(CordovaHelper.toCordovaCliArguments(commandData, platforms)); });
            });
        };
        CordovaWrapper.requirements = function (platforms) {
            return CordovaWrapper.getCordovaVersion()
                .then(function (version) {
                // If the cordova version is older than 5.1.0, the 'requirements' command does not exist
                if (!semver.gte(version, CordovaWrapper.CORDOVA_CHECK_REQS_MIN_VERSION)) {
                    return Q.reject(errorHelper.get(TacoErrorCodes.CommandInstallCordovaTooOld, version, CordovaWrapper.CORDOVA_CHECK_REQS_MIN_VERSION));
                }
                return Q.resolve({});
            })
                .then(function () {
                return CordovaWrapper.cordovaApiOrProcess(function (cordova) {
                    return cordova.raw.requirements(platforms);
                }, function () {
                    return ["requirements"].concat(platforms || []);
                }, { logLevel: InstallLogLevel.silent, captureOutput: true });
            });
        };
        /**
         * Wrapper for 'cordova create' command.
         *
         * @param {string} The version of the cordova CLI to use
         * @param {ICordovaCreateParameters} The cordova create options
         *
         * @return {Q.Promise<any>} An empty promise
         */
        CordovaWrapper.create = function (cordovaCliVersion, cordovaParameters) {
            CordovaHelper.prepareCordovaConfig(cordovaParameters);
            return CordovaHelper.wrapCordovaInvocation(cordovaCliVersion, function (cordova) {
                return cordova.raw.create(cordovaParameters.projectPath, cordovaParameters.appId, cordovaParameters.appName, cordovaParameters.cordovaConfig);
            }, InstallLogLevel.error);
        };
        CordovaWrapper.getGlobalCordovaVersion = function () {
            return CordovaWrapper.cli(["-v"], true).then(function (output) {
                return output.split("\n")[0].split(" ")[0];
            });
        };
        CordovaWrapper.getCordovaVersion = function () {
            return ProjectHelper.getProjectInfo().then(function (projectInfo) {
                if (projectInfo.cordovaCliVersion) {
                    return Q.resolve(projectInfo.cordovaCliVersion);
                }
                else {
                    return CordovaWrapper.getGlobalCordovaVersion();
                }
            });
        };
        CordovaWrapper.run = function (commandData, platforms) {
            platforms = platforms || null;
            return CordovaWrapper.getCordovaVersion().then(function (cordovaVersion) {
                return CordovaWrapper.cordovaApiOrProcess(function (cordova) {
                    return cordova.raw.run(CordovaHelper.toCordovaRunArguments(cordovaVersion, commandData, platforms));
                }, function () { return ["run"].concat(CordovaHelper.toCordovaCliArguments(commandData, platforms)); });
            });
        };
        CordovaWrapper.targets = function (commandData, platforms) {
            platforms = platforms || null;
            // Note: cordova <= 5.3.3 expects the options to "targets" to include "--list". If it does not,
            // it blindly splices off the last argument.
            return CordovaWrapper.getCordovaVersion().then(function (cordovaVersion) {
                return CordovaWrapper.cordovaApiOrProcess(function (cordova) {
                    return cordova.raw.targets(CordovaHelper.toCordovaTargetsArguments(cordovaVersion, commandData, platforms));
                }, function () { return ["targets"].concat(CordovaHelper.toCordovaCliArguments(commandData, platforms)); });
            });
        };
        /**
         * Perform an operation using either the Cordova API, or spwaning a Cordova process.
         * The first argument is a function which is given a Cordova object, and can operate on it as it wishes.
         * The second argument is a function which should return a list of strings to use as arguments to a Cordova process.
         *
         * We use a function for the second argument to delay computation until it is needed: If we are able to use the Cordova
         * in-process then we don't need to bother computing the CLI arguments.
         */
        CordovaWrapper.cordovaApiOrProcess = function (apiFunction, processArgs, options) {
            if (options === void 0) { options = {}; }
            return CordovaHelper.tryInvokeCordova(apiFunction, function () { return CordovaWrapper.cli(processArgs(), options.captureOutput); }, options);
        };
        CordovaWrapper.CORDOVA_CHECK_REQS_MIN_VERSION = "5.1.1";
        return CordovaWrapper;
    }());
    TacoUtility.CordovaWrapper = CordovaWrapper;
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=cordovaWrapper.js.map
