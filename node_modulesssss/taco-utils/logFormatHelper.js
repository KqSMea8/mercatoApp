// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
"use strict";
/// <reference path="../typings/node.d.ts" />
/// <reference path="../typings/colors.d.ts" />
var assert = require("assert");
/* tslint:disable:no-var-requires */
// Special case to allow using color package with index signature for style rules
var colors = require("colors/safe");
/* tslint:enable:no-var-requires */
var os = require("os");
var util = require("util");
colors.setTheme({
    error: ["red", "bold"],
    warn: ["yellow", "bold"],
    link: ["underline", "cyan"],
    title: "bold",
    success: ["green", "bold"],
    key: ["yellow", "bold"],
    highlight: "bold",
    helptitle: "bold",
    synopsis: ["green", "bold"],
    kitid: ["green", "bold"],
    deprecatedkit: ["red", "bold"],
    defaultkit: ["yellow", "bold"],
    command: ["green", "bold"]
});
var TacoUtility;
(function (TacoUtility) {
    var LogFormatHelper = (function () {
        function LogFormatHelper() {
        }
        /**
         * msg can be any string with styles classes defined in xml tags
         * <blue><bold>Hello World!!!</bold></blue>
         * if using any kind of formatting, make sure that it is well formatted
         * Ideally we should prefer using styles (for e.g. <title>, <success>) instead of bold, red, green kind of tags.
         * special tag <br> is supported to allow line breaks
         */
        LogFormatHelper.toFormattedString = function (msg) {
            var formattedMessage = "";
            if (msg) {
                msg = LogFormatHelper.convertBrTags(msg);
                var stylesStack = [];
                var startIndex = 0;
                // loop over all tags in the input string,
                // for start tag, push on the stack, for end tag pop from the stack
                // for every string section in between, print it with current styles on the stack
                LogFormatHelper.forEachTagMatch(msg, function (tag, isStartTag, tagStartIndex, tagEndIndex) {
                    // log current section of the string
                    formattedMessage += LogFormatHelper.colorize(msg.substring(startIndex, tagStartIndex), stylesStack);
                    startIndex = tagEndIndex;
                    if (isStartTag) {
                        stylesStack.push(tag);
                    }
                    else {
                        // verify same tag
                        if (stylesStack.length > 0 && stylesStack[stylesStack.length - 1] === tag) {
                            stylesStack.pop();
                        }
                        else {
                            assert.fail(util.format("Invalid format specified in %s. mismatched tag %s. stylestack %s", msg, tag, JSON.stringify(stylesStack)));
                            return null;
                        }
                    }
                });
                // print remaing string, outside any tags
                if (startIndex < msg.length) {
                    formattedMessage += LogFormatHelper.colorize(msg.substring(startIndex, msg.length), stylesStack);
                }
                // special handling for underline in the end
                if (stylesStack.length === 1) {
                    var tag = stylesStack.pop();
                    if (tag === "underline") {
                        formattedMessage += os.EOL + LogFormatHelper.repeat("-", LogFormatHelper.getFormattedStringLength(msg));
                    }
                }
                if (stylesStack.length !== 0) {
                    assert.equal(stylesStack.length, 0, util.format("Invalid format specified in %s. mismatched tags %s.", msg, stylesStack));
                    return null;
                }
            }
            formattedMessage += os.EOL;
            return formattedMessage;
        };
        /**
         * Helper method to convert a message to error format
         * @param {string} input string
         */
        LogFormatHelper.toError = function (msg) {
            return colors.error(LogFormatHelper.convertBrTags(msg) + os.EOL);
        };
        /**
         * Helper method to convert a message to warning format
         * @param {string} input string
         */
        LogFormatHelper.toWarning = function (msg) {
            return colors.warn(LogFormatHelper.convertBrTags(msg) + os.EOL);
        };
        /**
         * Helper method to return a repeated string
         * @param {string} string to repeat
         * @param {string} repeat count
         */
        LogFormatHelper.repeat = function (c, n) {
            return (n > 0) ? Array(n + 1).join(c) : "";
        };
        LogFormatHelper.getFormattedStringLength = function (msg) {
            return msg.replace(new RegExp(LogFormatHelper.TAG_REGEX, "gm"), "").length;
        };
        LogFormatHelper.isFormattedString = function (msg) {
            var regex = new RegExp(LogFormatHelper.TAG_REGEX, "gm");
            return regex.test(msg);
        };
        /**
         * Helper method to replace <br/> tags to end of line char
         * @param {string} input string
         */
        LogFormatHelper.convertBrTags = function (msg) {
            return msg.replace(/<br\/>/g, os.EOL);
        };
        LogFormatHelper.forEachTagMatch = function (msg, callback) {
            // regex to match again all start/end tags strictly without spaces
            var regex = new RegExp(LogFormatHelper.TAG_REGEX, "gm");
            // iterate over all start/end tags <foo>, </foo> 
            // push start tags on stack and remove start tags when end tags are encountered
            var match = regex.exec(msg);
            while (match) {
                var tagMatch = match[0];
                var style = match[1];
                var tagRightIndex = regex.lastIndex;
                var tagLeftIndex = tagRightIndex - match[0].length;
                var isStartTag = tagMatch.charAt(1) !== "/";
                callback(style, isStartTag, tagLeftIndex, tagRightIndex);
                match = regex.exec(msg);
            }
        };
        LogFormatHelper.colorize = function (str, styles) {
            if (styles.length > 0) {
                styles.forEach(function (style) {
                    if (style && colors[style]) {
                        str = colors[style](str);
                    }
                    //if no style defined string will not be colorized
                });
            }
            return str;
        };
        LogFormatHelper.TAG_REGEX = "<\/?([a-z]+)\/?>";
        return LogFormatHelper;
    }());
    TacoUtility.LogFormatHelper = LogFormatHelper;
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=logFormatHelper.js.map
