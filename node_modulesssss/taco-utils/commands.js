// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
"use strict";
/// <reference path="../typings/commandExample.d.ts" />
/// <reference path="../typings/node.d.ts" />
/// <reference path="../typings/Q.d.ts" />
/// <reference path="../typings/commandAlias.d.ts" />
var fs = require("fs");
var path = require("path");
var Q = require("q");
var tacoErrorCodes = require("./tacoErrorCodes");
var errorHelper = require("./tacoErrorHelper");
var TacoErrorCodes = tacoErrorCodes.TacoErrorCode;
var TacoUtility;
(function (TacoUtility) {
    var Commands;
    (function (Commands) {
        ;
        var TacoCommandBase = (function () {
            function TacoCommandBase() {
            }
            /**
             * Abstract method to be implemented by derived class.
             * Convert command line arguments into an appropriate format to determine what action to take
             */
            TacoCommandBase.prototype.parseArgs = function (args) {
                throw errorHelper.get(TacoErrorCodes.AbstractMethod);
            };
            TacoCommandBase.prototype.run = function (args) {
                try {
                    this.data = this.parseArgs(args);
                    return this.runCommand();
                }
                catch (err) {
                    return Q.reject(err);
                }
            };
            /**
             * Concrete implementation of ICommand's run
             * Parse the arguments using overridden parseArgs, and then select the most appropriate subcommand to run
             */
            TacoCommandBase.prototype.runCommand = function () {
                // Determine which subcommand we are executing
                var subCommand = this.getSubCommand();
                if (subCommand) {
                    return subCommand.run();
                }
                return Q.reject(errorHelper.get(TacoErrorCodes.CommandBadSubcommand, this.name, this.data.original.toString()));
            };
            TacoCommandBase.prototype.resolveAlias = function (token) {
                return (this.info.aliases && this.info.aliases[token]) ? this.info.aliases[token] : token;
            };
            TacoCommandBase.prototype.getSubCommand = function () {
                // first do a simple name match
                var name = this.data.remain[0];
                name = name ? this.resolveAlias(name) : name;
                for (var i = 0; i < this.subcommands.length; ++i) {
                    if (name === this.subcommands[i].name) {
                        return this.subcommands[i];
                    }
                }
                // if subcommand has specified a canHandleArgs, check if there is a subcommand
                // which can handle the args
                for (var i = 0; i < this.subcommands.length; ++i) {
                    var subCommand = this.subcommands[i];
                    if (subCommand.canHandleArgs && subCommand.canHandleArgs()) {
                        return subCommand;
                    }
                }
                return null;
            };
            return TacoCommandBase;
        }());
        Commands.TacoCommandBase = TacoCommandBase;
        /**
         * Factory to create new Commands classes
         */
        var CommandFactory = (function () {
            /**
             * Factory to create new Commands classes
             * initialize with json file containing commands
             */
            function CommandFactory(commandsInfoPath) {
                if (!fs.existsSync(commandsInfoPath)) {
                    throw errorHelper.get(TacoErrorCodes.TacoUtilsExceptionListingfile);
                }
                this.listings = require(commandsInfoPath).commands;
                this.aliases = require(commandsInfoPath).aliases;
            }
            /**
             * get specific task object, given task name
             */
            CommandFactory.prototype.getTask = function (name, inputArgs, commandsModulePath) {
                if (!name || !this.listings) {
                    throw errorHelper.get(TacoErrorCodes.TacoUtilsExceptionListingfile);
                }
                var moduleInfo = this.listings[name];
                if (!moduleInfo) {
                    // Check if {name} is a command alias
                    var commandForAlias = this.aliases ? this.aliases[name] : null;
                    if (commandForAlias) {
                        moduleInfo = this.listings[commandForAlias];
                    }
                    else {
                        return null;
                    }
                }
                var modulePath = path.join(commandsModulePath, moduleInfo.modulePath);
                if (!fs.existsSync(modulePath + ".js")) {
                    throw errorHelper.get(TacoErrorCodes.TacoUtilsExceptionMissingcommand, name);
                }
                var commandMod = require(modulePath);
                var moduleInstance = new commandMod();
                moduleInstance.info = moduleInfo;
                return moduleInstance;
            };
            return CommandFactory;
        }());
        Commands.CommandFactory = CommandFactory;
    })(Commands = TacoUtility.Commands || (TacoUtility.Commands = {}));
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=commands.js.map
