// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../typings/lodash.d.ts" />
"use strict";
var Q = require("q");
var TacoUtility;
(function (TacoUtility) {
    var PromisesUtils = (function () {
        function PromisesUtils() {
        }
        /*
        Wraps the execution of a lambda function, by executing an initializer before the function, and a finalizer after the function
        @initializer Code to execute before calling the main function that is codeToExecute
        @codeToExecute Main function that we want to execute, but we want to surround with some "support" tasks
        @finalizer Code that will be executed no matter what, after codeToExecute finishes executing
        @failHandler fail handler that will be executed if the codeToExecute is a promise, and it ge's rejected.

        @result The result of calling codeToExecute. The result won't be affected neither by @finalizer nor @failHandler
        which are executed only for side effects, and are independent of the result of this method
        */
        PromisesUtils.wrapExecution = function (initializer, codeToExecute, finalizer, failHandler) {
            if (failHandler === void 0) { failHandler = function () { }; }
            initializer();
            var result = codeToExecute();
            Q(result).finally(finalizer).fail(failHandler);
            return result;
        };
        /**
         * Sequentially runs a number of promises obtained from an array of values
         *  @value: array of values used to create chain of promises
         *  @func: accumulator function which runs over each array value and returns a promise which resolves to an accumulated value
         *  @initialValue: initial accumulated value
         */
        PromisesUtils.chain = function (values, func, initialValue) {
            return values.reduce(function (soFar, val) {
                return soFar.then(function (valueSoFar) {
                    return func(val, valueSoFar);
                });
            }, Q(initialValue));
        };
        /**
         * Syntactic sugar for promise or
         *  @conditions: a variable array of promises which resolve to true/false
         *
         *  @returns: resolves to true if either of the promises resolve to true, false otherwise
         */
        PromisesUtils.or = function () {
            var conditions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                conditions[_i - 0] = arguments[_i];
            }
            return PromisesUtils.logicalOp.apply(PromisesUtils, [true].concat(conditions));
        };
        /**
         * Syntactic sugar for promise and
         *  @conditions: a variable array of promises which resolve to true/false
         *
         *  @returns: resolves to true if both the promises resolve to true, false otherwise
         */
        PromisesUtils.and = function () {
            var conditions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                conditions[_i - 0] = arguments[_i];
            }
            return PromisesUtils.logicalOp.apply(PromisesUtils, [false].concat(conditions));
        };
        /**
         * Syntactic sugar for if/else style promises
         *  @condition: Promise resolving to true/false
         *  @promiseTrue: then promise if condition resolves to "true"
         *  @promiseFalse: then promise if condition resolves to "false"
         */
        PromisesUtils.condition = function (condition, promiseTrue, promiseFalse) {
            return Q(condition)
                .then(function (result) {
                return result ? PromisesUtils.getPromiseFunc(promiseTrue)() : PromisesUtils.getPromiseFunc(promiseFalse)();
            });
        };
        /**
         * Syntactic sugar for promise or
         *  @condition1: Promise1 resolving to true/false
         *  @condition2: Promise2 resolving to true/false
         *
         *  @returns: resolves to true if either of the promises resolve to true, false otherwise
         */
        PromisesUtils.logicalOp = function (exitValue) {
            var conditions = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                conditions[_i - 1] = arguments[_i];
            }
            var stepFunction = function (soFar, nextIndex) {
                if (soFar === exitValue) {
                    return Q(exitValue);
                }
                if (nextIndex < conditions.length) {
                    return PromisesUtils.getPromiseFunc(conditions[nextIndex])()
                        .then(function (result) { return stepFunction(result, nextIndex + 1); });
                }
                return Q(soFar);
            };
            return stepFunction(!exitValue, 0);
        };
        PromisesUtils.getPromiseFunc = function (promiseFuncOrVal) {
            if (typeof promiseFuncOrVal === "function") {
                return promiseFuncOrVal;
            }
            return function () { return Q(promiseFuncOrVal); };
        };
        return PromisesUtils;
    }());
    TacoUtility.PromisesUtils = PromisesUtils;
})(TacoUtility || (TacoUtility = {}));
module.exports = TacoUtility;

//# sourceMappingURL=promisesUtils.js.map
