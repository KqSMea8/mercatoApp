// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/should.d.ts"/>
/// <reference path="../../typings/mocha.d.ts"/>
/// <reference path="../../typings/nopt.d.ts"/>
/// <reference path="../../typings/tacoUtils.d.ts" />
"use strict";
/* tslint:disable:no-var-requires */
// var require needed for should module to work correctly
// Note not import: We don't want to refer to shouldModule, but we need the require to occur since it modifies the prototype of Object.
var shouldModule = require("should");
var fs = require("fs");
var os = require("os");
var mkdirp = require("mkdirp");
var path = require("path");
var rimraf = require("rimraf");
var argsHelper = require("../argsHelper");
var utils = require("../utilHelper");
var tacoErrorCodes = require("../tacoErrorCodes");
var ArgsHelper = argsHelper.ArgsHelper;
var UtilHelper = utils.UtilHelper;
var TacoErrorCodes = tacoErrorCodes.TacoErrorCode;
describe("UtilHelper", function () {
    describe("parseArguments()", function () {
        function hasUndefinedFlag(parsed, flagName) {
            return !parsed.options[flagName];
        }
        ;
        it("shouldn't throw errors for empty and missing parameters", function () {
            ArgsHelper.parseArguments({});
            ArgsHelper.parseArguments({}, {});
            ArgsHelper.parseArguments({}, {}, []);
            ArgsHelper.parseArguments({}, {}, [], 0);
        });
        it("should parse arguments properly when no flags are specified", function () {
            var parsed = ArgsHelper.parseArguments({}, {}, "create foo baz path a-es--".split(" "), 1);
            // Should have detected 0 flags, and have a remain of 4
            Object.keys(parsed.options).length.should.equal(0);
            parsed.remain.length.should.equal(4);
            // Verify remain order and values
            parsed.remain[0].should.equal("foo");
            parsed.remain[1].should.equal("baz");
            parsed.remain[2].should.equal("path");
            parsed.remain[3].should.equal("a-es--");
        });
        it("should parse arguments properly when nopt-Boolean and nopt-String flags are specified", function () {
            var knownOptions = {
                foo: String,
                bar: Boolean,
                baz: String
            };
            var parsed = ArgsHelper.parseArguments(knownOptions, {}, "create --bar boo --foo faz doo --baz baz".split(" "), 1);
            // Should have detected 3 flags, and have a remain of 2 (boo, doo)
            Object.keys(parsed.options).length.should.equal(3);
            parsed.remain.length.should.equal(2);
            // Verify flag values
            parsed.options["bar"].should.equal(true);
            parsed.options["foo"].should.equal("faz");
            parsed.options["baz"].should.equal("baz");
            // Verify remain order and values
            parsed.remain[0].should.equal("boo");
            parsed.remain[1].should.equal("doo");
        });
        it("should mark nopt-String flags as undefined if they have empty values", function () {
            var knownOptions = {
                foo: String,
                bar: Boolean,
                baz: String
            };
            var parsed = ArgsHelper.parseArguments(knownOptions, {}, "create boo --foo --baz --bar baz".split(" "), 1);
            // Should have detected 3 flags, and have a remain of 2 (boo, baz)
            Object.keys(parsed.options).length.should.equal(3);
            parsed.remain.length.should.equal(2);
            // Verify flag values
            parsed.options["bar"].should.equal(true);
            hasUndefinedFlag(parsed, "foo").should.equal(true);
            hasUndefinedFlag(parsed, "baz").should.equal(true);
            // Verify remain order and values
            parsed.remain[0].should.equal("boo");
            parsed.remain[1].should.equal("baz");
        });
        it("should successfully parse abbreviated flags", function () {
            var knownOptions = {
                foo: String,
                bar: Boolean,
                kaz: String
            };
            var parsed = ArgsHelper.parseArguments(knownOptions, {}, "create boo --fo --ka baz --b".split(" "), 1);
            // Should have detected 3 flags, and have a remain of 1 (boo)
            Object.keys(parsed.options).length.should.equal(3);
            parsed.remain.length.should.equal(1);
            // Verify flag values
            parsed.options["bar"].should.equal(true);
            hasUndefinedFlag(parsed, "foo").should.equal(true);
            parsed.options["kaz"].should.equal("baz");
            // Verify remain order and values
            parsed.remain[0].should.equal("boo");
        });
        it("should parse arguments properly when shorthands are specified", function () {
            var knownOptions = {
                foo: String,
                bar: Boolean,
                kaz: String
            };
            var shortHands = { k4: ["--kaz", "4.0.0"] };
            var parsed = ArgsHelper.parseArguments(knownOptions, shortHands, "create --ba --foo --k4 boo".split(" "), 1);
            // Should have detected 3 flags, and have a remain of 1 (boo)
            Object.keys(parsed.options).length.should.equal(3);
            parsed.remain.length.should.equal(1);
            // Verify flag values
            parsed.options["bar"].should.equal(true);
            hasUndefinedFlag(parsed, "foo").should.equal(true);
            parsed.options["kaz"].should.equal("4.0.0");
            // Verify remain order and values
            parsed.remain[0].should.equal("boo");
        });
        it("should handle complex scenarios correctly", function () {
            var knownOptions = {
                foo: String,
                bar: Boolean,
                baz: String
            };
            var parsed = ArgsHelper.parseArguments(knownOptions, {}, "create --ba -baz foo -f boo -fo foo ------foo --foo bar -bar bar foo -bazbaz --baz".split(" "), 1);
            // Should have detected 5 flags: ba, baz, foo, bar, bazbaz
            Object.keys(parsed.options).length.should.equal(5);
            // Should have remain of 2, bar and foo
            parsed.remain.length.should.equal(2);
            // Verify flag values
            parsed.options["ba"].should.equal(true);
            parsed.options["bar"].should.equal(true);
            hasUndefinedFlag(parsed, "baz").should.equal(true);
            parsed.options["bazbaz"].should.equal(true);
            parsed.options["foo"].should.equal("bar");
            // Verify remain order and values
            parsed.remain[0].should.equal("bar");
            parsed.remain[1].should.equal("foo");
        });
    });
    describe("parseUserJSON()", function () {
        var testHome = path.join(os.tmpdir(), "taco-utils", "parseUserJSON");
        before(function () {
            process.env["TACO_HOME"] = testHome;
            rimraf.sync(testHome);
            mkdirp.sync(testHome);
        });
        after(function () {
            rimraf(testHome, function (err) { }); // Not sync, and ignore errors
        });
        it("read UTF-16 file", function () {
            writeBufferAndValidate("utf16.json", function (stringified) { return new Buffer(stringified, "utf16le"); });
        });
        it("read UTF-8 file", function () {
            writeBufferAndValidate("utf8.json", function (stringified) { return new Buffer(stringified, "utf8"); });
        });
        it("read UTF-8 with BOM", function () {
            var parsedJson = UtilHelper.parseUserJSON(path.resolve(__dirname, "taco_utf8BOM.json"));
            parsedJson["cordova-cli"].should.equal("5.3.3");
        });
        it("read file which doesn't exist", function () {
            try {
                UtilHelper.parseUserJSON(path.resolve(__dirname, "nonExistentFile.json"));
                shouldModule.fail(true, false, "Expected error: " + TacoErrorCodes.ErrorUserJsonMissing);
            }
            catch (e) {
                e.errorCode.should.equal(TacoErrorCodes.ErrorUserJsonMissing);
            }
        });
        it("read malformed file", function () {
            writeBufferAndValidate("utf8.json", function (stringified) {
                var buffer = new Buffer(stringified, "utf8");
                var malformedBuffer = new Buffer(buffer.length + 3);
                // add some random bytes to the malformed buffer
                var badString = "\u00bd\u00bc\u00be";
                malformedBuffer.write(badString);
                buffer.copy(malformedBuffer, badString.length, 0);
                return malformedBuffer;
            }, TacoErrorCodes.ErrorUserJsonMalformed);
        });
        function writeBufferAndValidate(filename, getBuffer, expectedErrorCode) {
            var x = { "cordova-cli": 5.8 };
            var stringified = JSON.stringify(x);
            var buffer = getBuffer(stringified);
            var filepath = path.join(testHome, filename);
            fs.writeFileSync(filepath, buffer);
            try {
                var parsedJson = UtilHelper.parseUserJSON(filepath);
                if (expectedErrorCode) {
                    shouldModule.fail(true, false, "Expected error: " + expectedErrorCode);
                }
                else {
                    parsedJson.should.eql(x);
                }
            }
            catch (e) {
                if (expectedErrorCode) {
                    e.errorCode.should.equal(expectedErrorCode);
                }
                else {
                    shouldModule.fail(true, false, e);
                }
            }
        }
    });
});

//# sourceMappingURL=utilHelper.js.map
