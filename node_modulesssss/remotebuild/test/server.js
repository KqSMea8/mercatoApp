// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/mocha.d.ts" />
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/request.d.ts" />
/// <reference path="../../typings/should.d.ts" />
"use strict";
/* tslint:disable:no-var-requires */
// var require needed for should module to work correctly
// Note not import: We don't want to refer to shouldModule, but we need the require to occur since it modifies the prototype of Object.
var shouldModule = require("should");
/* tslint:enable:no-var-requires */
var fs = require("fs");
var nconf = require("nconf");
var net = require("net");
var os = require("os");
var path = require("path");
var request = require("request");
var rimraf = require("rimraf");
var Q = require("q");
var HostSpecifics = require("../lib/hostSpecifics");
var RemoteBuildConf = require("../lib/remoteBuildConf");
var server = require("../lib/server");
var testServerModuleFactory = require("./testServerModuleFactory");
var serverDir = path.join(os.tmpdir(), "remotebuild", "server");
var certsDir = path.join(serverDir, "certs");
var clientCertsDir = path.join(certsDir, "client");
var darwinOnlyTest = os.platform() === "darwin" ? it : it.skip;
describe("server", function () {
    before(function () {
        // Clear out settings for nconf
        nconf.overrides({});
        nconf.defaults({});
        nconf.use("memory");
        nconf.reset();
    });
    after(function () {
        rimraf(serverDir, function (err) { }); // Not sync, and ignore errors
    });
    beforeEach(function () {
        rimraf.sync(serverDir);
    });
    afterEach(function (done) {
        try {
            server.stop(done);
        }
        catch (e) {
            done();
        }
    });
    it("should start correctly in insecure mode", function (done) {
        // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
        nconf.overrides({ serverDir: serverDir, port: 3000, secure: false, lang: "en" });
        server.start(new RemoteBuildConf(nconf, true))
            .then(function () {
            fs.existsSync(serverDir).should.be.true;
            fs.existsSync(certsDir).should.be.false;
        }).then(function () {
            var deferred = Q.defer();
            request.get("http://localhost:3000", function (error, response, body) {
                response.statusCode.should.equal(200);
                deferred.resolve({});
            });
            return deferred.promise;
        }).done(function () { done(); }, done);
    });
    it("should fail gracefully if the port is taken", function (done) {
        var dummyServer = net.createServer(function (c) {
            // Don't care about connections, we just want to use up a port
        });
        var deferred = Q.defer();
        dummyServer.listen(3000, function () {
            deferred.resolve({});
        });
        deferred.promise.then(function () {
            // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
            nconf.overrides({ serverDir: serverDir, port: 3000, secure: false, lang: "en" });
            return server.start(new RemoteBuildConf(nconf, true));
        }).then(function () {
            dummyServer.close(function () {
                done(new Error("Server should not start successfully when the port is already taken!"));
            });
        }, function (err) {
            dummyServer.close(function () {
                if (err === "Unable to start server on port 3000. Address already in use.") {
                    done(); // Server should error out
                }
                else {
                    done(new Error("Unexpected error: " + err));
                }
            });
        });
    });
    // TODO (Devdiv: 1160573): Still need to work out how windows should work with certificates.
    darwinOnlyTest("should start correctly in secure mode on mac", function (done) {
        // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
        nconf.overrides({ serverDir: serverDir, port: 3000, secure: true, lang: "en" });
        server.start(new RemoteBuildConf(nconf, true))
            .then(function () {
            fs.existsSync(serverDir).should.be.ok;
            fs.existsSync(certsDir).should.be.ok;
            fs.existsSync(path.join(certsDir, "server-key.pem")).should.be.ok;
            fs.existsSync(path.join(certsDir, "server-cert.pem")).should.be.ok;
            fs.existsSync(path.join(certsDir, "ca-key.pem")).should.be.ok;
            fs.existsSync(path.join(certsDir, "ca-cert.pem")).should.be.ok;
        }).then(function () {
            var deferred = Q.defer();
            // Disabling strict SSL for unit testing
            request.get({ url: "https://localhost:3000", strictSSL: false }, function (error, response, body) {
                response.statusCode.should.equal(200);
                deferred.resolve({});
            });
            return deferred.promise;
        }).done(function () { done(); }, done);
    });
    darwinOnlyTest("should be able to download a certificate exactly once on mac", function (done) {
        // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
        nconf.overrides({ serverDir: serverDir, port: 3000, secure: true, lang: "en", pinTimeout: 10 });
        var config = new RemoteBuildConf(nconf, true);
        HostSpecifics.hostSpecifics.initialize(config).then(function () {
            return server.start(config);
        }).then(function () {
            fs.existsSync(clientCertsDir).should.be.ok;
        }).then(function () {
            var pins = fs.readdirSync(clientCertsDir);
            pins.length.should.equal(1);
            var downloadedPin = pins[0];
            var clientPfxSize = fs.statSync(path.join(clientCertsDir, downloadedPin, "client.pfx")).size;
            clientPfxSize.should.be.greaterThan(0);
            var deferred = Q.defer();
            // turn off strict SSL for unit testing
            var downloadedCertPath = path.join(serverDir, "downloaded-client.pfx");
            var downloadRequest = request.get({ url: "https://localhost:3000/certs/" + downloadedPin, strictSSL: false });
            var writeStream = fs.createWriteStream(downloadedCertPath);
            downloadRequest.pipe(writeStream);
            downloadRequest.on("error", done);
            writeStream.on("finish", function () {
                var downloadedPfxSize = fs.statSync(downloadedCertPath).size;
                if (downloadedPfxSize !== clientPfxSize) {
                    done(new Error("Download size does not match!"));
                }
                deferred.resolve(downloadedPin);
            });
            return deferred.promise;
        }).then(function (downloadedPin) {
            var deferred = Q.defer();
            request.get({ url: "https://localhost:3000/certs/" + downloadedPin, strictSSL: false }, function (error, response, body) {
                response.statusCode.should.equal(404);
                deferred.resolve({});
            });
            return deferred.promise;
        }).done(function () { done(); }, done);
    });
    it("should load server modules and serve requests from there", function (mocha) {
        var modPath = path.join("..", "test", "testServerModuleFactory"); // path is relative to lib/server.js since that's where the require is invoked
        var testModules = {};
        testModules["testServerModuleFactory"] = { mountPath: "testRoute", requirePath: modPath };
        // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
        nconf.overrides({ serverDir: serverDir, port: 3000, secure: false, lang: "en", pinTimeout: 10, modules: testModules });
        server.start(new RemoteBuildConf(nconf, true)).then(function () {
            testServerModuleFactory.TestServerModule.modConfig.mountPath.should.equal("testRoute");
        }).then(function () {
            var deferred = Q.defer();
            request.get("http://localhost:3000/testRoute/foo", function (error, response, body) {
                response.statusCode.should.equal(200);
                deferred.resolve({});
            });
            return deferred.promise;
        }).then(function () {
            testServerModuleFactory.TestServerModule.lastReq.url.should.equal("/foo");
        }).done(function () {
            mocha();
        }, mocha);
    });
});

//# sourceMappingURL=server.js.map
