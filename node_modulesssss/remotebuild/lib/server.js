// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/Q.d.ts" />
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/express.d.ts" />
/// <reference path="../../typings/expressExtensions.d.ts" />
/// <reference path="../../typings/helmet.d.ts" />
/// <reference path="../../typings/morgan.d.ts" />
/// <reference path="../../typings/errorhandler.d.ts" />
/// <reference path="../../typings/remotebuild.d.ts" />
"use strict";
var errorhandler = require("errorhandler");
var express = require("express");
var fs = require("fs");
var helmet = require("helmet");
var http = require("http");
var https = require("https");
var expressLogger = require("morgan");
var path = require("path");
var Q = require("q");
var semver = require("semver");
var util = require("util");
var HostSpecifics = require("./hostSpecifics");
var resources = require("../resources/resourceManager");
var utils = require("taco-utils");
var Logger = utils.Logger;
var UtilHelper = utils.UtilHelper;
var Server = (function () {
    function Server() {
    }
    Server.start = function (conf) {
        var app = express();
        app.use(expressLogger("dev"));
        app.use(errorhandler());
        if (conf.secure) {
            app.use(helmet.hsts({
                maxAge: 1000 * 60 * 60 * 24 * 365,
                includeSubdomains: true,
                force: true
            }));
        }
        var serverDir = conf.serverDir;
        UtilHelper.createDirectoryIfNecessary(serverDir);
        app.get("/", function (req, res) {
            res.status(200).send(resources.getStringForLanguage(req, "IndexPageContent", conf.port));
        });
        app.get("/certs/:pin", HostSpecifics.hostSpecifics.downloadClientCerts);
        app.get("/modules/:module", Server.getModuleMount);
        return utils.TelemetryHelper.generate("start", function (telemetry) {
            telemetry
                .add("isSecure", conf.secure, false)
                .add("nodeVersion", process.version.indexOf("v") === 0 ? process.version.slice(1) : process.version, false);
            return Server.initializeServerCapabilities(conf).then(function (serverCapabilities) {
                return Server.loadServerModules(conf, app, serverCapabilities);
            }).then(function () {
                return Server.startupServer(conf, app);
            }).then(Server.registerShutdownHooks).then(function () {
                Logger.log(resources.getString("CheckSettingsForInfo", conf.configFileLocation));
            })
                .fail(function (err) {
                Logger.logError(resources.getString("ServerStartFailed", err));
                if (err.stack) {
                    Logger.logError(err.stack);
                }
                throw err;
            });
        });
    };
    Server.stop = function (callback) {
        process.removeListener("uncaughtException", Server.errorShutdown);
        process.removeListener("SIGTERM", Server.shutdown);
        process.removeListener("SIGINT", Server.shutdown);
        if (Server.serverInstance) {
            var tempInstance = Server.serverInstance;
            Server.serverInstance = null;
            tempInstance.close(callback);
        }
        else if (callback) {
            callback(null);
        }
    };
    /**
     * Attempt to test each of the server modules against a separate instance of remotebuild which is assumed to be running with the same configuration
     */
    Server.test = function (conf, cliArguments) {
        return Server.initializeServerTestCapabilities(conf).then(function (serverTestCaps) {
            return Server.eachServerModule(conf, function (modGen, mod, moduleConfig) {
                return modGen.test(conf, moduleConfig, serverTestCaps, cliArguments).then(function () {
                    Logger.log(resources.getString("TestPassed", mod));
                }, function (err) {
                    Logger.logError(resources.getString("TestFailed", mod));
                    Logger.logError(err.message);
                    throw err;
                });
            });
        });
    };
    Server.resetServerCert = function (conf) {
        return HostSpecifics.hostSpecifics.resetServerCert(conf);
    };
    Server.generateClientCert = function (conf) {
        return HostSpecifics.hostSpecifics.generateClientCert(conf);
    };
    Server.saveConfig = function (conf) {
        return Server.eachServerModule(conf, function (modGen, mod, moduleConfig) {
            conf.setModuleConfig(mod, modGen.getConfig(conf, moduleConfig));
            return Q({});
        }).then(function () {
            conf.save();
        });
    };
    Server.initializeServerCapabilities = function (conf) {
        var serverCapPromises = [
            conf.secure ? HostSpecifics.hostSpecifics.initializeServerCerts(conf) : Q(null),
        ];
        return Q.all(serverCapPromises).spread(function (certStore) {
            var serverCapabilities = {};
            if (certStore) {
                serverCapabilities.certStore = certStore;
            }
            return serverCapabilities;
        });
    };
    Server.initializeServerTestCapabilities = function (conf) {
        var serverTestCapPromises = [
            conf.secure ? HostSpecifics.hostSpecifics.getHttpsAgent(conf) : Q(null),
        ];
        return Q.all(serverTestCapPromises).spread(function (agent) {
            var serverTestCapabilities = {};
            if (agent) {
                serverTestCapabilities.agent = agent;
            }
            return serverTestCapabilities;
        });
    };
    Server.loadServerModules = function (conf, app, serverCapabilities) {
        if (conf.usingDefaultModulesConfig) {
            Logger.logWarning(resources.getString("NoServerModulesSelected"));
        }
        var onlyAuthorizedClientRequest = function (req, res, next) {
            if (!req.client.authorized) {
                res.status(401).send(resources.getStringForLanguage(req, "UnauthorizedClientRequest"));
            }
            else {
                next();
            }
        };
        return Server.eachServerModule(conf, function (modGen, mod, moduleConfig) {
            return modGen.create(conf, moduleConfig, serverCapabilities).then(function (serverMod) {
                var modRouter = serverMod.getRouter();
                // These routes are fully secured through client cert verification:
                if (conf.secure) {
                    app.all("/" + moduleConfig.mountPath, onlyAuthorizedClientRequest);
                }
                app.use("/" + moduleConfig.mountPath, modRouter);
                Server.modules.push(serverMod);
            });
        });
    };
    Server.eachServerModule = function (conf, eachFunc) {
        return utils.PromisesUtils.chain(conf.modules, function (mod) {
            try {
                var requirePath = conf.moduleConfig(mod).requirePath || mod;
                var modGen = require(requirePath);
            }
            catch (e) {
                Logger.logError(resources.getString("UnableToLoadModule", mod));
                return Q.reject(e);
            }
            return eachFunc(modGen, mod, conf.moduleConfig(mod));
        });
    };
    Server.startupServer = function (conf, app) {
        return conf.secure ? Server.startupHttpsServer(conf, app) : Server.startupPlainHttpServer(conf, app);
    };
    Server.startupPlainHttpServer = function (conf, app) {
        return Q(http.createServer(app)).
            then(function (svr) {
            var deferred = Q.defer();
            // Increase the timeout to work around disconnects on larger uploads
            // https://blog.cloudflare.com/the-curious-case-of-slow-downloads/
            svr.setTimeout(5 * 60 * 1000);
            svr.on("error", function (err) {
                deferred.reject(Server.friendlyServerListenError(err, conf));
            });
            svr.listen(conf.port, function () {
                Server.serverInstance = svr;
                Server.serverConf = conf;
                Logger.log(resources.getString("InsecureServerStarted", conf.port));
                Server.writePid();
                deferred.resolve(svr);
            });
            return deferred.promise;
        });
    };
    Server.startupHttpsServer = function (conf, app) {
        var generatedNewCerts = false;
        var generatedClientPin;
        return HostSpecifics.hostSpecifics.getServerCerts().
            then(function (certStore) {
            if (certStore.newCerts) {
                generatedNewCerts = true;
                return HostSpecifics.hostSpecifics.generateClientCert(conf).
                    then(function (pin) {
                    generatedClientPin = pin;
                    return certStore;
                });
            }
            return Q(certStore);
        }).
            then(function (certStore) {
            var cipherList = ["ECDHE-ECDSA-AES256-GCM-SHA384",
                "ECDHE-ECDSA-AES128-GCM-SHA256",
                "ECDHE-RSA-AES256-SHA384",
                "ECDHE-RSA-AES128-SHA256",
                "ECDHE-RSA-AES256-SHA",
                "ECDHE-RSA-AES128-SHA",
                "DHE-RSA-AES256-GCM-SHA384",
                "DHE-RSA-AES128-GCM-SHA256",
                "DHE-RSA-AES256-SHA256",
                "DHE-RSA-AES256-SHA256",
                "DHE-RSA-AES128-SHA256",
                "DHE-RSA-AES256-SHA",
                "DHE-RSA-AES128-SHA",
                "!aNULL",
                "!eNULL",
                "!EXPORT",
                "!DES",
                "!RC4",
                "!MD5",
                "!PSK",
                "!SRP",
                "!CAMELLIA"];
            // TLS 1.2 is only supported in nodejs version 0.12.0 and greater, but TLS 1.0 is supported in nodejs version 0.10.0 and greater
            // Prior to 0.10.0 the option is not exposed, and we do not support that.
            // See https://github.com/nodejs/node/blob/0439a28d519fb6efe228074b0588a59452fc1677/ src / node_crypto.cc#L295 for an example
            // of where these protocol strings come from / are used.
            var protocol = semver.gte(process.versions.node, "0.12.0") ? "TLSv1_2_server_method" : "TLSv1_server_method";
            var sslSettings = {
                key: certStore.getKey(),
                cert: certStore.getCert(),
                ca: certStore.getCA(),
                ciphers: cipherList.join(":"),
                honorCipherOrder: true,
                secureProtocol: protocol,
                requestCert: true,
                rejectUnauthorized: false
            };
            return https.createServer(sslSettings, app);
        }).
            then(function (svr) {
            var deferred = Q.defer();
            // Increase the timeout to work around disconnects on larger uploads
            // https://blog.cloudflare.com/the-curious-case-of-slow-downloads/
            svr.setTimeout(5 * 60 * 1000);
            svr.on("error", function (err) {
                if (generatedNewCerts) {
                    HostSpecifics.hostSpecifics.removeAllCertsSync(conf);
                }
                deferred.reject(Server.friendlyServerListenError(err, conf));
            });
            svr.listen(conf.port, function () {
                Server.serverInstance = svr;
                Server.serverConf = conf;
                Logger.log(resources.getString("SecureServerStarted", conf.port));
                Server.writePid();
                deferred.resolve(svr);
            });
            return Q(deferred.promise);
        });
    };
    Server.friendlyServerListenError = function (err, conf) {
        if (err.code === "EADDRINUSE") {
            return resources.getString("ServerPortInUse", conf.port);
        }
        else {
            return err.toString();
        }
    };
    Server.writePid = function () {
        if (utils.ArgsHelper.argToBool(Server.serverConf.get("writePidToFile"))) {
            fs.writeFile(path.join(Server.serverConf.serverDir, "running_process_id"), process.pid);
        }
    };
    Server.registerShutdownHooks = function () {
        // It is strongly recommended in a NodeJs server to kill the process off on uncaughtException.
        Server.errorShutdown = function (err) {
            Logger.logError(resources.getString("UncaughtErrorShutdown"));
            Logger.logError(err.message);
            var stack = err.stack;
            if (stack) {
                Logger.logError(stack);
            }
            Logger.log(resources.getString("ServerShutdown"));
            Server.modules.forEach(function (mod) {
                mod.shutdown();
            });
            process.exit(1);
        };
        process.on("uncaughtException", Server.errorShutdown);
        // Opportunity to clean up builds on exit
        Server.shutdown = function () {
            Logger.log(resources.getString("ServerShutdown"));
            // BUG: Currently if buildManager.shutdown() is called while a build log is being written, rimraf will throw an exception on windows
            Server.modules.forEach(function (mod) {
                mod.shutdown();
            });
            Server.serverInstance.close();
            process.exit(0);
        };
        process.on("SIGTERM", Server.shutdown);
        process.on("SIGINT", Server.shutdown);
    };
    Server.getModuleMount = function (req, res) {
        var mod = req.params.module;
        var modConfig = Server.serverConf.moduleConfig(mod);
        if (mod && modConfig && modConfig.mountPath) {
            var mountLocation = modConfig.mountPath;
            var contentLocation = util.format("%s://%s:%d/%s", req.protocol, req.hostname, Server.serverConf.port, mountLocation);
            res.set({
                "Content-Location": contentLocation
            });
            res.status(200).send(mountLocation);
        }
        else {
            res.sendStatus(404);
        }
    };
    Server.modules = [];
    return Server;
}());
module.exports = Server;

//# sourceMappingURL=server.js.map
