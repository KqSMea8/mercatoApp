// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../../typings/node.d.ts" />
/// <reference path="../../../typings/Q.d.ts" />
/// <reference path="../../../typings/node.d.ts" />
/// <reference path="../../../typings/rimraf.d.ts" />
/// <reference path="../../../typings/certOptions.d.ts" />
"use strict";
var child_process = require("child_process");
var fs = require("fs");
var os = require("os");
var path = require("path");
var Q = require("q");
var readline = require("readline");
var rimraf = require("rimraf");
var util = require("util");
var resources = require("../../resources/resourceManager");
var tacoUtils = require("taco-utils");
var utils = tacoUtils.UtilHelper;
var logger = tacoUtils.Logger;
var PromisesUtils = tacoUtils.PromisesUtils;
var Certs = (function () {
    function Certs() {
    }
    Certs.resetServerCert = function (conf, yesOrNoHandler) {
        var certsDir = path.join(conf.serverDir, "certs");
        if (!fs.existsSync(certsDir)) {
            return Certs.initializeServerCerts(conf);
        }
        var shouldProceedDeferred = Q.defer();
        yesOrNoHandler = yesOrNoHandler || readline.createInterface({ input: process.stdin, output: process.stdout });
        var answerCallback = function (answer) {
            answer = answer.toLowerCase();
            if (resources.getString("OSXResetServerCertResponseYes").split("\n").indexOf(answer) !== -1) {
                yesOrNoHandler.close();
                shouldProceedDeferred.resolve(true);
            }
            else if (resources.getString("OSXResetServerCertResponseNo").split("\n").indexOf(answer) !== -1) {
                yesOrNoHandler.close();
                shouldProceedDeferred.resolve(false);
            }
            else {
                yesOrNoHandler.question(resources.getString("OSXResetServerCertPleaseYesNo") + os.EOL, answerCallback);
            }
        };
        yesOrNoHandler.question(resources.getString("OSXResetServerCertQuery") + os.EOL, answerCallback);
        return shouldProceedDeferred.promise.
            then(function (shouldProceed) {
            if (shouldProceed) {
                rimraf.sync(certsDir);
                return Certs.initializeServerCerts(conf)
                    .then(function (result) {
                    logger.log(resources.getString("OSXNoteAfterResetServerCert"));
                    return result;
                });
            }
            return Q({});
        });
    };
    Certs.generateClientCert = function (conf) {
        var certsDir = path.join(conf.serverDir, "certs");
        var caKeyPath = path.join(certsDir, "ca-key.pem");
        var caCertPath = path.join(certsDir, "ca-cert.pem");
        if (!fs.existsSync(caKeyPath) || !fs.existsSync(caCertPath)) {
            var error = resources.getString("CAFilesNotFound", caKeyPath, caCertPath);
            return Q(0).thenReject(error);
        }
        return Certs.makeClientPinAndSslCert(caKeyPath, caCertPath, certsDir, Certs.certOptionsFromConf(conf), conf).
            then(function (pin) {
            if (tacoUtils.ArgsHelper.argToBool(conf.get("suppressSetupMessage"))) {
                return pin;
            }
            Certs.printSetupInstructionsToConsole(conf, pin);
            return pin;
        });
    };
    Certs.initializeServerCerts = function (conf) {
        var certsDir = path.join(conf.serverDir, "certs");
        var certPaths = {
            certsDir: certsDir,
            caKeyPath: path.join(certsDir, "ca-key.pem"),
            caCertPath: path.join(certsDir, "ca-cert.pem"),
            serverKeyPath: path.join(certsDir, "server-key.pem"),
            serverCertPath: path.join(certsDir, "server-cert.pem"),
            newCerts: false
        };
        var certsExist = fs.existsSync(certPaths.caCertPath) && fs.existsSync(certPaths.serverKeyPath) && fs.existsSync(certPaths.serverCertPath);
        certPaths.newCerts = !certsExist;
        // should create certs if they don't exist or if caSertpath or serverCertPath has expired
        var shouldCreateCerts = PromisesUtils.or(!certsExist, function () { return Certs.isExpired(certPaths.caCertPath); }, function () { return Certs.isExpired(certPaths.serverCertPath); });
        return PromisesUtils.condition(shouldCreateCerts, function () {
            utils.createDirectoryIfNecessary(certsDir);
            fs.chmodSync(certsDir, 448); // 0700, user read/write/executable, no other permissions
            var options = Certs.certOptionsFromConf(conf);
            return Certs.makeSelfSigningCACert(certPaths.caKeyPath, certPaths.caCertPath, options).
                then(function () {
                return Certs.makeSelfSignedCert(certPaths.caKeyPath, certPaths.caCertPath, certPaths.serverKeyPath, certPaths.serverCertPath, options, conf);
            }).
                then(function () {
                certPaths.newCerts = true;
            });
        }, {})
            .then(function () {
            Certs.certStore = {
                newCerts: certPaths.newCerts,
                getKey: function () { return fs.readFileSync(certPaths.serverKeyPath); },
                getCert: function () { return fs.readFileSync(certPaths.serverCertPath); },
                getCA: function () { return fs.readFileSync(certPaths.caCertPath); }
            };
            return Certs.certStore;
        });
    };
    Certs.getServerCerts = function () {
        if (Certs.certStore) {
            return Q(Certs.certStore);
        }
        else {
            return Q.reject(new Error(resources.getString("CertificatesNotConfigured")));
        }
    };
    Certs.isExpired = function (certPath) {
        return Certs.displayCert(certPath, ["dates"]).
            then(function (output) {
            var notAfter = new Date(output.stdout.substring(output.stdout.indexOf("notAfter=") + 9, output.stdout.length - 1));
            return (notAfter.getTime() < new Date().getTime());
        });
    };
    // display fields an array of any of these: 'subject', 'issuer', 'dates', etc. (see https://www.openssl.org/docs/apps/x509.html)
    Certs.displayCert = function (certPath, displayFields) {
        // openssl x509 -noout -in selfsigned-cert.pem -subject -issuer -dates
        var args = "x509 -noout -in " + certPath;
        (displayFields || []).forEach(function (f) {
            args += " -" + f;
        });
        return Certs.openSslPromise(args);
    };
    Certs.removeAllCertsSync = function (conf) {
        var certsDir = path.join(conf.serverDir, "certs");
        if (fs.existsSync(certsDir)) {
            rimraf.sync(certsDir);
        }
    };
    Certs.downloadClientCerts = function (conf, pinString) {
        Certs.purgeExpiredPinBasedClientCertsSync(conf);
        var clientCertsDir = path.join(conf.serverDir, "certs", "client");
        var pin = parseInt(pinString, 10);
        if (isNaN(pin)) {
            throw { code: 400, id: "InvalidPin" };
        }
        var pinDir = path.join(clientCertsDir, "" + pin);
        var pfx = path.join(pinDir, "client.pfx");
        if (!fs.existsSync(pfx)) {
            throw { code: 404, id: "ClientCertNotFoundForPIN" };
        }
        return pfx;
    };
    Certs.invalidatePIN = function (conf, pinString) {
        var pinDir = path.join(conf.serverDir, "certs", "client", "" + parseInt(pinString, 10));
        rimraf(pinDir, utils.emptyMethod);
    };
    Certs.purgeExpiredPinBasedClientCertsSync = function (conf) {
        var clientCertsDir = path.join(conf.serverDir, "certs", "client");
        if (!fs.existsSync(clientCertsDir)) {
            return;
        }
        var pinTimeoutInMinutes = conf.pinTimeout;
        var expiredIfOlderThan = new Date().getTime() - (pinTimeoutInMinutes * 60 * 1000);
        fs.readdirSync(clientCertsDir).forEach(function (f) {
            var pfx = path.join(clientCertsDir, f, "client.pfx");
            if (fs.existsSync(pfx) && fs.statSync(pfx).mtime.getTime() < expiredIfOlderThan) {
                rimraf.sync(path.join(clientCertsDir, f));
            }
        });
    };
    // Makes a CA cert that will be used for self-signing our server and client certs.
    // Exported for tests
    Certs.makeSelfSigningCACert = function (caKeyPath, caCertPath, options) {
        options = options || {};
        var days = options.days || Certs.CERT_DEFAULTS.days;
        var country = options.country || Certs.CERT_DEFAULTS.country;
        var cn = Certs.CERT_DEFAULTS.ca_cn;
        return Certs.openSslPromise("req -newkey rsa:4096 -x509 -days " + days + " -nodes -subj /C=" + country + "/CN=" + cn + " -keyout " + caKeyPath + " -out " + caCertPath);
    };
    // Makes a new private key and certificate signed with the CA.
    // Exported for tests
    Certs.makeSelfSignedCert = function (caKeyPath, caCertPath, outKeyPath, outCertPath, options, conf) {
        options = options || {};
        var csrPath = path.join(path.dirname(outCertPath), "CSR-" + path.basename(outCertPath));
        var days = options.days || Certs.CERT_DEFAULTS.days;
        var cn = options.cn || Certs.CERT_DEFAULTS.client_cn;
        var cnfPath = path.join(conf.serverDir, "certs", "openssl.cnf");
        Certs.writeConfigFile(cnfPath, conf);
        return Certs.openSslPromise("genrsa -out " + outKeyPath + " 2048").
            then(function () {
            return Certs.openSslPromise("req -new -subj /CN=" + cn + " -key " + outKeyPath + " -out " + csrPath + " -config " + cnfPath);
        }).
            then(function () {
            return Certs.openSslPromise("x509 -req -days " + days + " -in " + csrPath + " -CA " + caCertPath + " -CAkey " + caKeyPath +
                " -extensions v3_req -extfile " + cnfPath + " -set_serial 01 -out " + outCertPath);
        }).
            then(function () {
            fs.unlinkSync(csrPath);
        });
    };
    Certs.verifyCert = function (caCertPath, certPath) {
        return Certs.openSslPromise("verify -CAfile " + caCertPath + " " + certPath);
    };
    Certs.openSslPromise = function (args) {
        var deferred = Q.defer();
        child_process.exec("openssl " + args, function (error, stdout, stderr) {
            if (Certs.debug) {
                logger.log("exec openssl " + args);
                logger.log(util.format("stdout: %s", stdout));
                logger.log(util.format("stderr: %s", stderr));
            }
            if (error) {
                deferred.reject(error);
            }
            else {
                deferred.resolve({ stdout: stdout.toString(), stderr: stderr.toString() });
            }
        });
        return deferred.promise;
    };
    Certs.certOptionsFromConf = function (conf) {
        var options = {};
        if (conf.certExpirationDays < 1) {
            logger.log(resources.getString("CertExpirationInvalid", conf.certExpirationDays, Certs.CERT_DEFAULTS.days));
            options.days = Certs.CERT_DEFAULTS.days;
        }
        else {
            options.days = conf.certExpirationDays;
        }
        return options;
    };
    Certs.writeConfigFile = function (cnfPath, conf) {
        var net = os.networkInterfaces();
        var cnf = "[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = v3_req\n[req_distinguished_name]\nC_default = US\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n[alt_names]\n";
        var hostname = conf.hostname;
        cnf += util.format("DNS.1 = %s\n", hostname);
        var ipCount = 1;
        Object.keys(net).forEach(function (key) {
            for (var i = 0; i < net[key].length; i++) {
                if (net[key][i].address && !net[key][i].internal) {
                    cnf += util.format("IP.%d = %s\n", ipCount, net[key][i].address);
                    ipCount++;
                }
            }
        });
        fs.writeFileSync(cnfPath, cnf);
    };
    Certs.makeClientPinAndSslCert = function (caKeyPath, caCertPath, certsDir, options, conf) {
        options = options || {};
        options.cn = Certs.CERT_DEFAULTS.client_cn;
        var clientCertsPath = path.join(certsDir, "client");
        utils.createDirectoryIfNecessary(clientCertsPath);
        // 6 digit random pin (Math.random excludes 1.0)
        var pin = 100000 + Math.floor(Math.random() * 900000);
        var pinDir = path.join(clientCertsPath, "" + pin);
        var pfxPath = path.join(pinDir, "client.pfx");
        var clientKeyPath = path.join(pinDir, "client-key.pem");
        var clientCertPath = path.join(pinDir, "client-cert.pem");
        utils.createDirectoryIfNecessary(pinDir);
        return Certs.makeSelfSignedCert(caKeyPath, caCertPath, clientKeyPath, clientCertPath, options, conf).
            then(function () {
            return Certs.makePfx(caCertPath, clientKeyPath, clientCertPath, pfxPath);
        }).
            then(function () {
            fs.unlinkSync(clientKeyPath);
            fs.unlinkSync(clientCertPath);
            return pin;
        });
    };
    Certs.makePfx = function (caCertPath, keyPath, certPath, outPfxPath, options) {
        options = options || {};
        var name = Certs.CERT_DEFAULTS.pfx_name;
        return Certs.openSslPromise("pkcs12 -export -in " + certPath + " -inkey " + keyPath + " -certfile " + caCertPath + " -out " + outPfxPath +
            " -name \'" + name + "\' -password pass:");
    };
    Certs.printSetupInstructionsToConsole = function (conf, pin) {
        var host = conf.hostname;
        var port = conf.port;
        var pinTimeoutInMinutes = conf.pinTimeout;
        logger.log(resources.getString("OSXCertSetupInformation", host, port, pin));
        if (pinTimeoutInMinutes) {
            logger.log(resources.getString("OSXCertSetupPinTimeout", pinTimeoutInMinutes));
        }
        else {
            logger.log(resources.getString("OSXCertSetupNoPinTimeout"));
        }
        logger.log("remotebuild certificates generate");
        logger.log("");
    };
    Certs.debug = false;
    Certs.CERT_DEFAULTS = {
        days: 1825,
        country: "US",
        ca_cn: os.hostname().substring(0, 50) + ".RB.CA",
        pfx_name: os.hostname().substring(0, 50) + ".RB.CC",
        client_cn: os.hostname().substring(0, 50) + ".RB" // Note: we need the client cert name to be a prefix of the CA cert so both are retrieved in the client. Otherwise it complains about self signed certificates
    };
    Certs.certStore = null;
    return Certs;
}());
module.exports = Certs;

//# sourceMappingURL=darwinCerts.js.map
