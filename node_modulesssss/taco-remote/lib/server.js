// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/Q.d.ts" />
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/express.d.ts" />
/// <reference path="../../typings/expressExtensions.d.ts" />
/// <reference path="../../typings/tacoRemoteLib.d.ts" />
/// <reference path="../../typings/remotebuild.d.ts" />
/// <reference path="../../typings/serve-index.d.ts" />
"use strict";
var express = require("express");
var os = require("os");
var path = require("path");
var serveIndex = require("serve-index");
var util = require("util");
var BuildManager = require("./buildManager");
var Help = require("./help");
var HostSpecifics = require("./hostSpecifics");
var selftest = require("./selftest");
var TacoRemoteConfig = require("./tacoRemoteConfig");
var utils = require("taco-utils");
var ServerModuleFactory = (function () {
    function ServerModuleFactory() {
    }
    ServerModuleFactory.prototype.create = function (conf, modConfig, serverCapabilities) {
        var tacoRemoteConf = new TacoRemoteConfig(conf, modConfig);
        return HostSpecifics.hostSpecifics.initialize(tacoRemoteConf).then(function () {
            return new Server(tacoRemoteConf, modConfig.mountPath);
        });
    };
    ServerModuleFactory.prototype.test = function (conf, modConfig, serverTestCapabilities, cliArguments) {
        var host = util.format("http%s://%s:%d", utils.ArgsHelper.argToBool(conf.secure) ? "s" : "", conf.hostname || os.hostname, conf.port);
        var downloadDir = path.join(conf.serverDir, "selftest", "taco-remote");
        utils.UtilHelper.createDirectoryIfNecessary(downloadDir);
        return selftest.test(host, modConfig.mountPath, downloadDir, cliArguments.indexOf("--device") !== -1, serverTestCapabilities.agent);
    };
    ServerModuleFactory.prototype.printHelp = function (conf, modConfig) {
        var tacoRemoteConf = new TacoRemoteConfig(conf, modConfig);
        var resources = new utils.ResourceManager(path.join(__dirname, "..", "resources"), conf.lang);
        var help = new Help();
        help.run(["taco-remote"]).done();
    };
    ServerModuleFactory.prototype.getConfig = function (conf, modConfig) {
        var tacoRemoteConf = new TacoRemoteConfig(conf, modConfig);
        return tacoRemoteConf.serialize();
    };
    return ServerModuleFactory;
}());
var serverModuleFactory = new ServerModuleFactory();
var Server = (function () {
    function Server(conf, modPath) {
        this.serverConf = conf;
        this.modPath = modPath;
        // Initialize the build manager (after our app settings are all setup)
        this.buildManager = new BuildManager(conf);
        this.resources = new utils.ResourceManager(path.join(__dirname, "..", "resources"), conf.lang);
    }
    Server.prototype.getRouter = function () {
        var router = express.Router();
        router.post("/build/tasks", this.submitNewBuild.bind(this));
        router.get("/build/tasks/:id", this.getBuildStatus.bind(this));
        router.get("/build/tasks/:id/log", this.getBuildLog.bind(this));
        router.get("/build/tasks", this.getAllBuildStatus.bind(this));
        router.get("/build/:id", this.getBuildStatus.bind(this));
        router.get("/build/:id/download", this.checkBuildThenAction(this.buildManager.downloadBuild));
        router.get("/build/:id/emulate", this.checkBuildThenAction(this.buildManager.emulateBuild));
        router.get("/build/:id/deploy", this.checkBuildThenAction(this.buildManager.deployBuild));
        router.get("/build/:id/run", this.checkBuildThenAction(this.buildManager.runBuild));
        router.get("/build/:id/debug", this.checkBuildThenAction(this.buildManager.debugBuild));
        router.use("/files", serveIndex(this.buildManager.getBaseBuildDir()));
        router.use("/files", express.static(this.buildManager.getBaseBuildDir()));
        return router;
    };
    Server.prototype.shutdown = function () {
        this.buildManager.shutdown();
    };
    // Submits a new build task
    Server.prototype.submitNewBuild = function (req, res) {
        var port = this.serverConf.port;
        var modPath = this.modPath;
        var self = this;
        this.buildManager.submitNewBuild(req).then(function (buildInfo) {
            var contentLocation = util.format("%s://%s:%d/%s/build/tasks/%d", req.protocol, req.hostname, port, modPath, buildInfo.buildNumber);
            res.set({
                "Content-Type": "application/json",
                "Content-Location": contentLocation
            });
            res.status(202).json(buildInfo.localize(req, self.resources));
        }, function (err) {
            if (err.code) {
                res.status(err.code).send(err.toString());
            }
            else {
                res.set({ "Content-Type": "application/json" });
                res.status(400).send({ status: self.resources.getStringForLanguage(req, "InvalidBuildRequest"), errors: err.toString() });
            }
        }).done();
    };
    // Queries on the status of a build task, used by a client to poll
    Server.prototype.getBuildStatus = function (req, res) {
        var buildInfo = this.buildManager.getBuildInfo(req.params.id);
        if (buildInfo) {
            buildInfo.localize(req, this.resources);
            if (!buildInfo.message) {
                // We can't localize this in this package, we need to get whichever package serviced the request to localize the request
                buildInfo.localize(req, buildInfo["pkg"].locResources);
            }
            res.status(200).json(buildInfo);
        }
        else {
            res.status(404).send(this.resources.getStringForLanguage(req, "BuildNotFound", req.params.id));
        }
    };
    // Retrieves log file for a build task, can be used by a client when build failed
    Server.prototype.getBuildLog = function (req, res) {
        var buildInfo = this.buildManager.getBuildInfo(req.params.id);
        if (buildInfo) {
            res.set("Content-Type", "text/plain");
            this.buildManager.downloadBuildLog(req.params.id, parseInt(req.query.offset, 10) || 0, res);
        }
        else {
            res.status(404).send(this.resources.getStringForLanguage(req, "BuildNotFound", req.params.id));
        }
    };
    // Queries on the status of all build tasks
    Server.prototype.getAllBuildStatus = function (req, res) {
        var allBuildInfo = this.buildManager.getAllBuildInfo();
        res.status(200).json(allBuildInfo);
    };
    Server.prototype.checkBuildThenAction = function (func) {
        var self = this;
        return function (req, res) {
            var buildInfo = self.buildManager.getBuildInfo(req.params.id);
            if (!buildInfo) {
                res.status(404).send(self.resources.getStringForLanguage(req, "BuildNotFound", req.params.id));
                return;
            }
            if (!buildInfo.buildSuccessful) {
                res.status(404).send(self.resources.getStringForLanguage(req, "BuildNotCompleted", buildInfo.status));
                return;
            }
            func.call(self.buildManager, buildInfo, req, res);
        };
    };
    return Server;
}());
module.exports = serverModuleFactory;

//# sourceMappingURL=server.js.map
