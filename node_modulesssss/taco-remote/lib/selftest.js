// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
"use strict";
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/request.d.ts" />
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/cordovaExtensions.d.ts" />
/// <reference path="../../typings/fstream.d.ts" />
/// <reference path="../../typings/tar.d.ts" />
var fs = require("fs");
var fstream = require("fstream");
var os = require("os");
var path = require("path");
var Q = require("q");
var request = require("request");
var rimraf = require("rimraf");
var tar = require("tar");
var util = require("util");
var zlib = require("zlib");
var tacoUtils = require("taco-utils");
var resources = require("../resources/resourceManager");
var BuildInfo = tacoUtils.BuildInfo;
var Logger = tacoUtils.Logger;
var TacoPackageLoader = tacoUtils.TacoPackageLoader;
var utils = tacoUtils.UtilHelper;
var SelfTest = (function () {
    function SelfTest() {
    }
    /**
     * Attempt to submit a build to the specified host running taco-remote on the specifed mount point
     *
     * @param {string} host The protocol, hostname, and port of the server. E.g. "http://localhost:3000"
     * @param {string} modMountPoint The location where taco-remote is mounted. E.g. "cordova"
     * @param {string} downloadDir The folder to save any resulting output to
     * @param {boolean} deviceBuild Whether to build for device, or the emulator.
     * @param {https.Agent} agent An agent to use if making a secure connection.
     *
     * @return a promise which is resolved if the build succeeded, or rejected if the build failed.
     */
    SelfTest.test = function (host, modMountPoint, downloadDir, deviceBuild, agent) {
        var vcordova = "5.4.0"; // Using 5.4.0 for maximum node compatibility
        var tempFolder = path.join(os.tmpdir(), "taco-remote", "selftest");
        rimraf.sync(tempFolder);
        utils.createDirectoryIfNecessary(tempFolder);
        var cordovaApp = path.join(tempFolder, "helloCordova");
        return TacoPackageLoader.lazyRequire("cordova", "cordova@" + vcordova).then(function (cordova) {
            // Create a project and add a plugin
            return cordova.raw.create(cordovaApp).then(function () {
                var originalCwd = process.cwd();
                process.chdir(cordovaApp);
                return cordova.raw.plugin("add", ["cordova-plugin-device"], {}).finally(function () {
                    process.chdir(originalCwd);
                });
            });
        }, function (err) {
            Logger.logError(resources.getString("CordovaAcquisitionFailed", vcordova, err.toString()));
            throw err;
        }).then(function () {
            // Submit the project to be built
            var vcli = require("../package.json").version;
            var cfg = "debug";
            var buildOptions = deviceBuild ? "--device" : "--emulator";
            var tgzProducingStream = null;
            // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
            var cordovaAppDirReader = new fstream.Reader({ path: cordovaApp, type: "Directory", filter: SelfTest.filterForTar });
            tgzProducingStream = cordovaAppDirReader.pipe(tar.Pack()).pipe(zlib.createGzip());
            var submitDeferred = Q.defer();
            var buildUrl = util.format("%s/%s/build/tasks/?vcordova=%s&vcli=%s&cfg=%s&command=build&options=%s", host, modMountPoint, vcordova, vcli, cfg, buildOptions);
            // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
            tgzProducingStream.pipe(request.post({ url: buildUrl, agent: agent }, function (submitError, submitResponse, submitBody) {
                if (submitError) {
                    submitDeferred.reject(submitError);
                    return;
                }
                var buildingUrl = submitResponse.headers["content-location"];
                if (!buildingUrl) {
                    submitDeferred.reject(new Error(submitBody));
                    return;
                }
                submitDeferred.resolve(buildingUrl);
            }));
            tgzProducingStream.on("error", function (err) {
                submitDeferred.reject(err);
            });
            return submitDeferred.promise;
        }).then(function (buildingUrl) {
            // Wait for the project to finish building
            var pingInterval = 5000;
            var maxPings = 10;
            var i = 0;
            var buildDeferred = Q.defer();
            var ping = setInterval(function () {
                i++;
                Logger.log(util.format("%d...", i));
                // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
                request.get({ url: buildingUrl, agent: agent }, function (statusError, statusResponse, statusBody) {
                    if (statusError) {
                        clearInterval(ping);
                        buildDeferred.reject(statusError);
                    }
                    var build = JSON.parse(statusBody);
                    if (build["status"] === BuildInfo.ERROR || build["status"] === BuildInfo.DOWNLOADED || build["status"] === BuildInfo.INVALID) {
                        clearInterval(ping);
                        buildDeferred.reject(new Error("Build Failed: " + statusBody));
                    }
                    else if (build["status"] === BuildInfo.COMPLETE) {
                        clearInterval(ping);
                        if (deviceBuild) {
                            var downloadUrl = util.format("%s/%s/build/%d/download", host, modMountPoint, build["buildNumber"]);
                            var buildNumber = build["buildNumber"];
                            var downloadFile = path.join(downloadDir, "build_" + buildNumber + "_download.zip");
                            var writeStream = fs.createWriteStream(downloadFile);
                            writeStream.on("error", function (err) {
                                buildDeferred.reject(err);
                            });
                            // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
                            request({ url: downloadUrl, agent: agent }).pipe(writeStream).on("finish", function () {
                                buildDeferred.resolve(build);
                            }).on("error", function (err) {
                                buildDeferred.reject(err);
                            });
                        }
                        else {
                            buildDeferred.resolve(build);
                        }
                    }
                    else if (i > maxPings) {
                        buildDeferred.reject(new Error(resources.getString("ExceededMaxPings", maxPings)));
                        clearInterval(ping);
                    }
                });
            }, pingInterval);
            return buildDeferred.promise;
        }).then(function (build) {
            // Check that the project built with the plugin we added
            var downloadUrl = util.format("%s/%s/files/%d/cordovaApp/plugins/ios.json", host, modMountPoint, build["buildNumber"]);
            var deferred = Q.defer();
            // TODO: Remove the casting once we've get some complete/up-to-date .d.ts files. See https://github.com/Microsoft/TACO/issues/18
            request({ url: downloadUrl, agent: agent }, function (error, response, body) {
                if (error) {
                    deferred.reject(error);
                }
                try {
                    var pluginJson = JSON.parse(body);
                    if (pluginJson["installed_plugins"]["cordova-plugin-device"]) {
                        deferred.resolve({});
                    }
                    else {
                        deferred.reject("Did not find expected plugin in project built remotely");
                    }
                }
                catch (e) {
                    deferred.reject(e);
                }
            });
            return deferred.promise;
        });
    };
    // Archive up what is needed for an ios build and put current process user id on entries
    SelfTest.filterForTar = function (reader, props) {
        if (reader.parent) {
            if (reader.parent.basename.match(/^platforms$/)) {
                return false;
            }
        }
        if (process.platform !== "win32") {
            props.uid = process.getuid();
        }
        return true;
    };
    return SelfTest;
}());
module.exports = SelfTest;

//# sourceMappingURL=selftest.js.map
