// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/rimraf.d.ts" />
"use strict";
var rimraf = require("rimraf");
var resources = require("../resources/resourceManager");
var utils = require("taco-utils");
var Logger = utils.Logger;
var BuildRetention = (function () {
    function BuildRetention(baseBuildDir, config) {
        this.maxBuildsToKeep = config.maxBuildsToKeep;
    }
    BuildRetention.deleteBuilds = function (builds, toDelete, sync) {
        for (var i = 0; i < toDelete.length; ++i) {
            var idx = toDelete[i];
            var buildInfo = builds[idx];
            Logger.log(resources.getString("BuildRetentionDelete", buildInfo.buildNumber, buildInfo.buildDir));
            if (sync) {
                rimraf.sync(buildInfo.buildDir);
            }
            else {
                BuildRetention.deleteBuildDirectoryAsync(buildInfo.buildDir);
            }
            delete builds[idx];
        }
    };
    BuildRetention.deleteBuildDirectoryAsync = function (buildDir, callback) {
        rimraf(buildDir, function (err) {
            if (callback) {
                callback(err);
            }
        });
    };
    BuildRetention.prototype.purge = function (builds) {
        var buildNumbers = Object.keys(builds);
        var nBuildsToDelete = buildNumbers.length - this.maxBuildsToKeep;
        if (nBuildsToDelete <= 0) {
            return;
        }
        // eligible builds do not include those queued up or currently building.
        var eligibleBuilds = [];
        for (var i = 0; i < buildNumbers.length; i++) {
            var buildInfo = builds[buildNumbers[i]];
            if (BuildRetention.statesToNotDelete.indexOf(buildInfo.status) === -1) {
                eligibleBuilds.push(buildInfo);
            }
        }
        ;
        // sort eligible builds by oldest first, then delete required number
        eligibleBuilds.sort(function (b1, b2) {
            var diff = b1.submissionTime - b2.submissionTime;
            return (diff === 0) ? 0 : (diff > 0 ? +1 : -1);
        });
        if (nBuildsToDelete > eligibleBuilds.length) {
            nBuildsToDelete = eligibleBuilds.length;
        }
        var numbersToDelete = eligibleBuilds.slice(0, nBuildsToDelete).map(function (b) {
            return b.buildNumber.toString();
        });
        Logger.log(resources.getString("BuildRetentionPreDelete", nBuildsToDelete));
        BuildRetention.deleteBuilds(builds, numbersToDelete, false);
    };
    BuildRetention.prototype.deleteAllSync = function (builds) {
        var buildNumbers = Object.keys(builds);
        BuildRetention.deleteBuilds(builds, buildNumbers, true);
    };
    BuildRetention.statesToNotDelete = [utils.BuildInfo.BUILDING, utils.BuildInfo.EXTRACTED, utils.BuildInfo.UPLOADING, utils.BuildInfo.UPLOADED];
    return BuildRetention;
}());
module.exports = BuildRetention;

//# sourceMappingURL=buildRetention.js.map
